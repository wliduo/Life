<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dolyw</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dolyw.com/"/>
  <updated>2019-05-16T13:14:41.230Z</updated>
  <id>https://dolyw.com/</id>
  
  <author>
    <name>随风飘的纸飞机</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七岁那年以为抓住那只蝉就能抓住夏天</title>
    <link href="https://dolyw.com/2019/05/16/2019-05-16-About-Me/"/>
    <id>https://dolyw.com/2019/05/16/2019-05-16-About-Me/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2019-05-16T13:14:41.230Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://dolyw.gitee.io/reader/Image/headt.png" height="150px" width="150px"></p><h2 align="center">随心</h2><p align="center"><b>愿你出走半生，归来仍是少年</b></p><hr><p>每个人一生中，都会经历很多次单枪匹马的战斗，有些路只能一个人走，但当你回头望，总会发现有人守在不远处，不言语，但就在那里。</p><p>能够有几个知冷知热，懂你悲喜的人，不管是亲人、朋友、爱人，都会让这漫漫一生，变得格外温暖。</p><p><strong>有人说，人一生会遇到约2920万人，我们经历的大部分遇见都是擦肩而过，有些人只是表面的客套和寒暄，而有些人却是真正知根知底，交心交情。</strong></p><p>大多数人只关心你飞得高不高，只有几个真正懂你的人，会在意你过得好不好，会看到你的辛苦和付出，心疼你的不容易。</p><p>有些苦难必须一个人咬着牙熬过去，但能够有人在你脆弱想哭的时候听你吐槽，给你拥抱，陪你一起消化掉那些负能量，就像是黑夜中一盏温暖的灯光，让你积蓄起继续前行的力量。</p><p><strong>遇见容易相守难，欢喜容易懂得难。</strong></p><p>这一生最难得的，不是有人爱你，而是有人真正懂你，懂你的心事，懂你的沉默，也懂你的欲言又止。</p><p>就像廖一梅说的：“人这一辈子，遇到爱，遇到性，都不稀罕，稀罕的是遇到了解。”</p><p><strong>最好的关系，其实就两个字-懂得～</strong></p><hr><p>很久之前就读过林夕的一句话，每次提到“懂得”这个词都会想到这句话：</p><p>“很多人结婚只是为了找个跟自己一起看电影的人，而不是能够分享看电影心得的人，如果只是为了找个伴，我不愿意结婚，我自己一个人也能够去看电影。”</p><p>是啊，如果遇不到那个能够真正懂自己的人，那在一起也不过是凑合将就，三观和灵魂都难以契合，鸡同鸭讲，又如何幸福长久呢？</p><p><strong>任何一份关系都是这样，彼此体谅，互相懂得，才能够彼此陪伴着走更长的路。</strong></p><p>懂你的人会知道你喜欢的是苹果而不是梨子，他不会非要你坚强，也不会以自己的方式去爱你，而是会以你喜欢的方式，给你想要的感情。</p><p>懂你的人会在你不想说话的时候默默陪伴你，而不是一味地问你“又怎么了”，他会愿意主动去思考你的想法，照顾到你的情绪和感受，不让你一个人哭，不让你一个人脆弱。</p><p>和懂你的人在一起，是轻松自在的，彼此静坐也不会尴尬，不用费心找话题，不用每句话思虑再三，因为懂得，所以坦然，不用担心会打扰彼此。</p><p><strong>那些无法用言语讲出来的心事和满腹的委屈，有人能懂，能够轻声对你说：“我都知道”，真的是莫大的慰藉。</strong></p><hr><p><strong>人和人之间，不过一世的缘分，和懂你的人在一起，才不负人生一场。</strong></p><p><strong>心比长相好，懂比爱重要，不要消耗浪费自己的真心和感情，留给值得的人，才有意义。</strong></p><p>就像曾被科学家称为“世界上最孤独的鲸鱼”的Alice，也许它也曾想过，是否这一生就只能孤独地游走在深海，无人能听懂。</p><p>但Alice最终还是遇到了相同的频率，往后的漫长岁月，它的歌声能够被听懂，它的情绪也能够被了解。</p><p><strong>不必将就，努力做你自己，前行的路上，总会遇到和你志同道合的同路者。</strong></p><p><strong>愿余生，我们都能找到合适自己的人，彼此懂得，过上舒心自在的日子。</strong></p><hr><p><img src="https://dolyw.gitee.io/reader/Image/201810/normal/10010.png" alt="image text"></p><hr>]]></content>
    
    <summary type="html">
    
      每个人一生中，都会经历很多次单枪匹马的战斗，有些路只能一个人走，但当你回头望，总会发现有人守在不远处，不言语，但就在那里...
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>解决GitHub访问不了的方法</title>
    <link href="https://dolyw.com/2019/05/15/2019-05-15-Github-Failure/"/>
    <id>https://dolyw.com/2019/05/15/2019-05-15-Github-Failure/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-16T12:34:51.960Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>一直用的GitHub，突然一下子不能访问了，手机都可以上</strong>  </p><ul><li>解决方法  </li></ul><ol><li><p>在本地host文件中添加映射，步骤如下  </p></li><li><p>用文本编辑器打开hosts文件，Windows系统位于C:\Windows\System32\drivers\etc目录下(其他系统请自行查阅)  </p></li><li><p>打开<a href="http://tool.chinaz.com/dns" target="_blank" rel="noopener">http://tool.chinaz.com/dns</a>，这是一个查询域名映射关系的工具  </p></li><li><p>查询<code>github.global.ssl.fastly.net</code>和<code>assets-cdn.github.com</code>两个地址  </p></li><li><p>反复多查几次，选择一个比较稳定，延迟较低的TTL按如下方式添加到Host文件  </p></li></ol><ul><li>最后，为了你的方便我找了几个访问速度还不错的，直接复制就可以使用<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Github</span></span><br><span class="line"><span class="comment"># 13.229.188.59 github.com</span></span><br><span class="line"><span class="comment"># 151.101.109.194 github.global.ssl.fastly.net</span></span><br><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.112</span> <span class="string">github.com</span></span><br><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.113</span> <span class="string">github.com</span></span><br><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.119</span> <span class="string">gist.github.com</span></span><br><span class="line"><span class="number">151.101</span><span class="number">.185</span><span class="number">.194</span> <span class="string">github.global.ssl.fastly.net</span></span><br><span class="line"><span class="number">151.101</span><span class="number">.100</span><span class="number">.133</span> <span class="string">assets-cdn.github.com</span></span><br><span class="line"><span class="number">151.101</span><span class="number">.100</span><span class="number">.133</span> <span class="string">raw.githubusercontent.com</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      解决GitHub访问不了的方法
    
    </summary>
    
      <category term="Life" scheme="https://dolyw.com/categories/Life/"/>
    
    
      <category term="Life" scheme="https://dolyw.com/tags/Life/"/>
    
      <category term="Github" scheme="https://dolyw.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>换个名字，换个域名，重新注册谷歌账号</title>
    <link href="https://dolyw.com/2019/05/11/2019-05-11-Toggle-Domain-Name/"/>
    <id>https://dolyw.com/2019/05/11/2019-05-11-Toggle-Domain-Name/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-16T11:33:34.623Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一直觉得<code>wang926454</code>这个名字太low太长，所以一直想改名字，选来选去，从<code>eren</code>到<code>dodo</code>到<code>lido</code>最后用了<code>dolyw</code>，因为<code>doly</code>很多人已经使用了，没办法~</p><p>首先改的就是<code>Github</code>了，改了之后先就是一堆邮件发过来说<code>Github Page</code>构造出问题了，发现进个人首页404，以前的项目链接什么的还是会转发的，这样就可以了</p><p>然后处理的是域名了，cn域名还是不太好(突然改政策什么的)，本来想在Godaddy买me域名的，但是续费要120，太贵了还是算了，直接腾讯云买了<code>dolyw.com</code>这个域名，只要60，<code>wang64.cn</code>这个域名不用了，到时候设置一个转发</p><p>转发全部用的<code>CODING</code>，还有<code>www.dolyw.com</code>也是，因为<code>Github</code>只能设置一个<code>dolyw.com</code>，不能再设置<code>www.dolyw.com</code>了</p><p>接下来就是处理网站的<code>wang64.cn</code>的引用全改成<code>dolyw.com</code></p><p>把CSDN的图片链接改下，还把<code>ViewGenerator</code>代码的注释全改了</p><p>重新注册了一个谷歌账号本来想<a href="mailto:dolyw@gmail.com" target="_blank" rel="noopener">dolyw@gmail.com</a>，结果最少要6位…就加了个6，变成<a href="mailto:dolyw6@gmail.com" target="_blank" rel="noopener">dolyw6@gmail.com</a>了</p><p><strong>就这样改来改去，最后域名改成dolyw.com了，累</strong></p>]]></content>
    
    <summary type="html">
    
      一直觉得wang926454这个名字太low太长，所以一直想改名字，选来选去，从eren到dodo到lido最后用了dolyw.....
    
    </summary>
    
      <category term="Life" scheme="https://dolyw.com/categories/Life/"/>
    
    
      <category term="Life" scheme="https://dolyw.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>如果你不想工作了，就去这四个地方走走</title>
    <link href="https://dolyw.com/2019/04/21/2019-04-21-Do-Not-Work/"/>
    <id>https://dolyw.com/2019/04/21/2019-04-21-Do-Not-Work/</id>
    <published>2019-04-21T06:20:18.000Z</published>
    <updated>2019-05-16T12:34:17.701Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>微博上曾经有过这样一个征集：你现在最焦虑的问题是什么？</strong></p><p>底下呼声最高的答案竟然是：<strong>不想工作怎么破？</strong></p><p>现代的成年人，越来越喜欢把“不想上班”“想辞职”等话挂在嘴边，仿佛就像是问”你今早吃了什么”一样稀松平常。</p><p>其实啊，如果你只是一时的抱怨、疲倦，想寻求他人安慰，是可以理解的。</p><p>但假如有一天，你真的不想工作了，不妨去这四个地方看一看。</p><hr><h3 id="1-医院"><a href="#1-医院" class="headerlink" title="1. 医院"></a>1. 医院</h3><p>说到医院，很多人脑海中，都浮现出熙攘的人群夹杂着刺鼻药水的冰冷画面。</p><p><strong>只有真正患过重病的人才懂得：医院的墙承载了多少祷告，同时就见证了多少心酸。</strong></p><p>身为医生的父亲，曾在饭桌上讲过这样一个故事：</p><p>有天夜里，门诊来了一对穿着朴素，相互搀扶的夫妇来看病，男子面色苍白，目测大概五十多岁。</p><p>检查结果是胃癌早期，医生跟他们说：“还好发现的及时，现在立刻住院动手术，治愈率还是很高的。”</p><p>男子问：“大概多少钱？”</p><p>医生说：“你先准备5万吧。”</p><p>男子愣住了，许久，才艰难地对医生说：“医生，您先给我开点药吧，我回家自己养养。”</p><p>旁边的妻子忍不住蹲下身，放声大哭，声音里都是绝望。</p><p>后来，他们开了点药就走了，再也没有出现在医院里……想必结局也是闻者伤心。</p><p>现实，就是这么冰冷和残酷。</p><p><strong>除了生离死别，医院里更是上映着一幕幕命运与金钱的无情较量。</strong></p><p>去年，有篇长文刷爆了朋友圈。</p><p>作者的岳父因为不小心得了感冒，从流感演变到肺炎，最后住进ICU，每天的费用高达8000-20000元。</p><p>更别提之后的“人工肺设备费用6万，插管每天2万起”了，仅仅29天，整个家庭为此几乎倾家荡产，依旧没能挽留岳父的性命。</p><p>别再谈什么岁月静好、诗和远方了，疾病总是夹杂着风霜雨雪呼啸而来，不跟你打任何招呼，就轻而易举的压垮整个家庭。</p><p><strong>如果你不想工作了，去医院走一走，去ICU门口转一转，你会看到疾病是怎样快速榨干一个普通家庭的全部积蓄，你会看到那些因没钱放弃治疗的病人，眼里是怎样的无助与绝望。</strong></p><p><strong>工作再苦再累，却能给你带来实实在在的收入，而金钱就是你拿来抵御未知风险，与这个命运无常的世界战斗的一把利刃。</strong></p><h3 id="2-凌晨4点的街头"><a href="#2-凌晨4点的街头" class="headerlink" title="2. 凌晨4点的街头"></a>2. 凌晨4点的街头</h3><p><strong>听过这样一句话：“没有见过凌晨4点的城市的人，不足以谈人生。”</strong></p><p>凌晨4点，在几乎所有人都陷入沉睡之时，有些人却要为了生计开始忙碌奔走……</p><p>凌晨4点的街头，呈现的是一个与白天截然不同的世界。</p><blockquote><p>3: 30，货车司机已经装好货，马不停蹄的开始一段新的漫长行程；<br>4: 00，卖早点的婆婆推着餐车，穿过刺骨的寒风走出狭窄的胡同；<br>4: 30，满脸倦容的医生刚刚完成一台连续12小时的手术，拖着疲惫的身子走出大门；<br>5: 00，唤醒城市的环卫工人开始走上萧瑟的街头……</p></blockquote><p><strong>当你真正见过凌晨4点的街头，你就会明白，这个世界不会因为黑夜的降临懈怠和熄火。</strong></p><p>你会明白，成年人的生活里从来就没有“容易”这两个字，但是为了生活，总有人竭尽全力，负重前行。</p><p><strong>与此相比，我们能坐在温暖明亮，窗明几净的办公室里，做着一份体面而踏实的工作，简直就是莫大的幸福。</strong></p><p>川端康成曾写道：“凌晨四点醒来，发现海棠花未眠。”</p><p><strong>哪怕生活再苦再累，这世间总会有一道微光，留给所有不曾放弃的人。</strong></p><h3 id="3-机场"><a href="#3-机场" class="headerlink" title="3. 机场"></a>3. 机场</h3><p>张雪峰曾经在演讲中说过一段话：</p><p><strong>如果孩子不想读书，就带他去四个地方看看：汽车客运站，火车站，高铁站，飞机场。</strong></p><p>我觉得对于不想工作的人来说，这些地方同样适用。</p><blockquote><p>先去趟机场，看看周围西装革履来往匆匆的行人，看看他们脸上从容自信的笑容；<br>再去趟火车站，看看背着大包小裹的人群一窝蜂的涌入逼仄狭小的车厢，还要在燥热嘈杂的环境下、伴随着各种不明气味度过漫长的时光……</p></blockquote><p>想一想未来的自己，希望选择哪种出行方式。</p><p>诚然，我们大部分的人生来平凡，没坐过飞机，没吃过牛排的人比比皆是。</p><p><strong>平凡并不可怕，可怕的是没经历过奋斗便甘于平庸，最后一生碌碌无为，还安慰自己平凡可贵。</strong></p><p>我们有幸来到这个世界上，不就是为了体验各种美好事物吗？</p><p>品尝没吃过的美食，走没走过的路，看没看过的美景，享受经济自由带来的美好感受，这才是人生的终极意义啊。</p><p>都说世界那么大，可是你不努力奋斗，拿什么去看看？</p><p>我们常说，读书可以改变命运，这话不假。</p><p><strong>可是读书往往只是获得一条走向成功的捷径，而真正的较量，要从步入社会那刻开始。</strong></p><p>同样是上班，有些人精益求精地做好每件事，下班后也不忘充实自己；有些人却每天无所事事地混日子。</p><p>人生本来就是一场追逐，有些人在途中就停止了前进，有些人即使磕磕碰碰满身伤痕仍然匍匐前行。</p><p>对于成年人来说，如果你不甘于平凡，如果你想扭转你的人生，如果你想跨过山和大海，看更大的世界，那么你唯一的途径就是努力工作。</p><p><strong>想过什么样的生活，拥有什么样的人生，你自己选择。</strong></p><h3 id="4-家里"><a href="#4-家里" class="headerlink" title="4. 家里"></a>4. 家里</h3><p>去年有段时间，我工作干得特别不开心，一赌气就辞职，回到了家里。</p><p>我妈没有责备我，反而安慰了我两句，还做了一大桌我喜欢吃的菜。</p><p>吃到一半，一直不见我妈上桌，我爸悄悄告诉我：“你妈刚才在厨房把昨天的剩菜吃了，你也知道她这人，一向不喜欢浪费……”</p><p>听到这话，我鼻子一酸，眼泪不争气的直往下滚。</p><p>我爸看我哭了，手忙脚乱的想帮我擦去泪水：</p><p>“傻女儿，你哭啥，不想干咱就不干了，老爸这身体多挣几年钱没问题，又不是养不起你！”</p><p>我哭得更厉害了，那种感动夹杂着羞愧从四面八方涌入，把我裹得密不透风。</p><p>为人子女一场，不仅没有让父母过上更好的生活，还要让年过半百的他们为了我的下半生操持打拼，我有什么资格喊累？我有什么资格轻易放弃？</p><p><strong>有人说：“成功的速度，一定要超过父母老去的速度。”</strong></p><p>我们这一生，只欠父母，只怕的就是当父母辛苦一生，到了晚年躺在病床上，真正需要我们的时候，我们却无能为力。</p><p>最近，《都挺好》的热播把原生家庭再次带入了大众视线。</p><p>剧中，姚晨饰演的苏明玉，通过十年的拼搏奋斗，勇敢地走出了原生家庭的泥潭，从一个不被关爱的平凡女孩，一路逆袭成了人生赢家。</p><p><strong>努力赚钱，就是打破原生家庭圈子的唯一通道。</strong></p><p>当你一天不想工作了，就回家去看看，看看你父母吃的穿的是什么，你吃的穿的是什么，<strong>你就会知道你之所以过得“岁月静好，现世安稳”，是因为背后有年迈的父母在替你负重前行。</strong></p><p>至于被原生家庭拖累的孩子，更要回家看看，看看那个你拼命想逃离的家，看看那些你曾经憎恶的脸，坚定地告诉自己，唯有努力拼搏到彻底经济独立，才能换来自己的涅槃重生。</p><hr><p>周末和几个朋友聊起各自的工作，发现真是各有各的苦：</p><blockquote><p>小A人际关系紧张，同事都有意无意的孤立她，每一天都很煎熬；<br>小B动不动就出差、加班，经常连续半个月连轴转，感觉快撑不下去了；<br>小C已经改了12版设计，客户还是不满意，大半夜把她骂的狗血喷头……</p></blockquote><p>你看，几乎每个人都有想辞职的理由，每个人都有想放弃的瞬间。</p><p><strong>可是因为不想让之前所有的努力付之流水，因为想坚持自己的梦想，想证明自己我能行，他们都选择咬紧牙关义无反顾地走了下去。</strong></p><p>有些事情不是看到希望才会去坚持，而是坚持了才会看到希望。</p><p>没有谁的工作是不辛苦的，放弃和逃避，的确是逃离痛苦最快的捷径，却不是长久之计。</p><p><strong>当一个人老去，回首曾经，最痛苦的事情，不是“失败”，而是“我本可以”。</strong></p><p>再努力一下，再坚持一下，当你拼尽全力熬过去之后，你会发现，苦笑泪水都是经历，坎坷挫折都是试炼，那些杀不死你的终将会让你更强大。</p><p><strong>挫折会来，也会过去；热泪会流下，也会收起。</strong></p><p><strong>愿你在每一个拼命努力的日子都能被温柔以待；</strong></p><p><strong>愿你负担得起自己的骄傲，去征服向往的城堡；</strong></p><p><strong>愿你受过的所有苦痛，最终都会变成这世界赠予你的礼物。</strong></p><p><em>与君共勉</em></p><hr><p><strong>作者：Kris在路上</strong><br><strong>链接：<a href="https://mp.weixin.qq.com/s/XSX1ST9yKGq6ExRcg76F2A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XSX1ST9yKGq6ExRcg76F2A</a></strong><br><strong>来源：微信</strong>  </p>]]></content>
    
    <summary type="html">
    
      微博上曾经有过这样一个征集：你现在最焦虑的问题是什么？
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>Java性能优化的50个细节（珍藏版）</title>
    <link href="https://dolyw.com/2019/04/20/2019-04-20-50-Details/"/>
    <id>https://dolyw.com/2019/04/20/2019-04-20-50-Details/</id>
    <published>2019-04-20T07:18:18.000Z</published>
    <updated>2019-05-16T11:32:24.791Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。</p><p>● 1. 尽量在合适的场合使用单例</p><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p><p>● 2. 尽量避免随意使用静态变量</p><p>当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p><p>● 3. 尽量避免过多过常地创建Java对象</p><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度地重用对象，最好能用基本的数据类型或数组来替代对象。</p><p>● 4. 尽量使用final修饰符</p><p>带有final修饰符的类是不可派生的。在JAVA核心API中，有许多应用final的例子，例如java、lang、String，为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关），此举能够使性能平均提高50%。</p><p>如：让访问实例内变量的getter/setter方法变成”final：</p><p>简单的getter/setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAF</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  _size = size;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DAF_fixed</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  _size = size;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>● 5. 尽量使用局部变量</p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快；其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p><p>● 6. 尽量处理好包装类型和基本类型两者的使用场所</p><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p><p>● 7. 慎用synchronized，尽量减小synchronize的方法</p><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以，synchronize的方法尽量减小，并且应尽量使用方法同步代替代码块同步。</p><p>● 9. 尽量不要使用finalize方法</p><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p><p>● 10. 尽量使用基本数据类型代替对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p><p>● 11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList</p><p>HashTable、Vector等使用了同步机制，降低了性能。</p><p>● 12. 尽量合理的创建HashMap</p><p>当你要创建一个比较大的hashMap时，充分利用这个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>;</span><br></pre></td></tr></table></figure><p>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p><p>● 13. 尽量减少对变量的重复计算</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br></pre></td></tr></table></figure></p><p>应该改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = list.size(); i &lt; len; i++)</span><br></pre></td></tr></table></figure></p><p>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p><p>● 14. 尽量避免不必要的创建</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line"> list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>应该改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line"> A a = <span class="keyword">new</span> A();</span><br><span class="line"> list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>● 15. 尽量在finally块中释放资源</p><p>程序中使用到的资源应当被释放，以避免资源泄漏，这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><p>● 16. 尽量使用移位来代替’a/b’的操作</p><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = a / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> num = a / <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p>应该改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = a &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解。</p><p>● 17.尽量使用移位来代替’a*b’的操作</p><p>同样的，对于’*’操作，使用移位的操作将会更快和更有效<br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = a * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> num = a * <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p>应该改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = a &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>● 18. 尽量确定StringBuffer的容量</p><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>● 19. 尽量早释放无用对象的引用</p><p>大部分时，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> ……</span><br><span class="line"> Obj=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> ……</span><br><span class="line"> Obj=<span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">// 执行耗时，耗内存操作；或调用耗时，耗内存的方法</span></span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p><p>● 20. 尽量避免使用二维数组</p><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p><p>● 21. 尽量避免使用split</p><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p><p>● 22. ArrayList &amp; LinkedList</p><p>一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。</p><p>● 23. 尽量使用System.arraycopy ()代替通过来循环复制数组</p><p>System.arraycopy() 要比通过循环来复制数组快的多。</p><p>● 24. 尽量缓存经常使用的对象</p><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p><p>● 25. 尽量避免非常大的内存分配</p><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p><p>● 26. 慎用异常</p><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p><p>如果您创建一个 Exception ，就得付出代价，好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，你甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常，幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p><p>● 27. 尽量重用对象</p><p>特别是String对象的使用中，出现字符串连接情况时应使用StringBuffer代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。</p><p>● 28. 不要重复初始化变量</p><p>默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成null，整数变量设置成0，float和double变量设置成0.0，逻辑值设置成false。当一个类从另一个类派生时，这一点尤其应该注意，因为用new关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。</p><p>这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法。比如initXXX()中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：public int state = this.getState()。</p><p>● 29. 在java+Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。</p><p>● 30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。</p><p>● 31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。</p><p>● 32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。</p><p>● 33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层</p><p>Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误Exception都能获取到的，虚拟机报错Exception就获取不到，必须用Error获取。</p><p>● 34. 通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能</p><p>StringBuffer的默认容量为16，当StringBuffer的容量达到最大容量时，它会将自身容量增加到当前的2倍+2，也就是2*n+2。无论何时，只要StringBuffer到达它的最大容量，它就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给StringBuffer设置一个合理的初始化容量值，是很有必要的！</p><p>● 35. 合理使用java.util.Vector</p><p>Vector与StringBuffer类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector的默认存储能力为10个元素，扩容加倍。</p><p>vector.add(index,obj) 这个方法可以将元素obj插入到index位置，但index以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于remove(int index)方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用removeAllElements()方法。</p><p>如果要删除vector里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如int index = indexOf（obj）;vector.remove(index)。</p><p>● 38. 不用new关键字创建对象的实例</p><p>用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了Cloneable接口，我们可以调用它的clone()方法。clone()方法不会调用任何类构造函数。</p><p>下面是Factory模式的一个典型实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Credit <span class="title">getNewCredit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Credit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的代码使用clone()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Credit BaseCredit = <span class="keyword">new</span> Credit();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Credit <span class="title">getNewCredit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (Credit) BaseCredit.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>● 39. 不要将数组声明为：public static final</p><p>● 40. HaspMap的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String[]&gt; paraMap = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String[]&gt; entry : paraMap.entrySet()) &#123;</span><br><span class="line"> String appFieldDefId = entry.getKey();</span><br><span class="line"> String[] values = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用散列值取出相应的Entry做比较得到结果，取得entry的值之后直接取key和value。</p><p>● 41. array(数组)和ArrayList的使用</p><p>array 数组效率最高，但容量固定，无法动态改变，ArrayList容量可以动态增长，但牺牲了效率。</p><p>● 42. 单线程应尽量使用 HashMap, ArrayList,除非必要，否则不推荐使用HashTable,Vector，它们使用了同步机制，而降低了性能。</p><p>● 43. StringBuffer,StringBuilder的区别在于</p><p>java.lang.StringBuffer 线程安全的可变字符序列。一个类似于String的字符串缓冲区，但不能修改。StringBuilder与该类相比，通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p><p>为了获得更好的性能，在构造StringBuffer或StringBuilder时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用StringBuffer仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用StringBuffer。</p><p>● 44. 尽量使用基本数据类型代替对象。</p><p>● 45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。</p><p>● 46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。</p><p>● 47. 应尽可能避免使用内在的GET,SET方法。</p><p>● 48.避免枚举，浮点数的使用。</p><p>以下举几个实用优化的例子：</p><p>● 一、避免在循环条件中使用复杂表达式</p><p>在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEL</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) <span class="comment">// Violation</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更正：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEL_fixed</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = vector.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>● 二、为’Vectors’ 和 ‘Hashtables’定义初始大小</p><p>JVM为Vector扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见Vector容量的扩大是一个颇费时间的事。</p><p>通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DIC</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObjects</span> <span class="params">(Object[] o)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// if length &gt; 10, Vector needs to expand</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; o.length;i++) &#123;</span><br><span class="line">  v.add(o); <span class="comment">// capacity before it can add more elements.</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> Vector v = <span class="keyword">new</span> Vector(); <span class="comment">// no initialCapacity.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更正：<br>自己设定初始大小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Vector v = <span class="keyword">new</span> Vector(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">public</span> Hashtable hash = <span class="keyword">new</span> Hashtable(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>● 三、在finally块中关闭Stream</p><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><p>● 四、使用’System.arraycopy ()’代替通过来循环复制数组</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IRB</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">   array1[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">   array2[i] = array1 [i]; <span class="comment">// Violation</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更正：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IRB</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">   array1 [i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line">  System.arraycopy(array1, <span class="number">0</span>, array2, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>● 五、让访问实例内变量的getter/setter方法变成”final”</p><p>简单的getter/setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAF</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  _size = size;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DAF_fixed</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  _size = size;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>● 六、对于常量字符串，用’String’ 代替 ‘StringBuffer’</p><p>常量字符串并不需要动态改变长度。</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USC</span> </span>&#123;</span><br><span class="line"> <span class="function">String <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  StringBuffer s = <span class="keyword">new</span> StringBuffer (<span class="string">"Hello"</span>);</span><br><span class="line">  String t = s + <span class="string">"World!"</span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更正：把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。</p><p>● 七、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">STR</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  String string = s + <span class="string">"d"</span> <span class="comment">// violation.</span></span><br><span class="line">  String = <span class="string">"abc"</span> + <span class="string">"d"</span> <span class="comment">// violation.</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更正：<br>将一个字符的字符串替换成’ ‘<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">STR</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  String string = s + <span class="string">'d'</span></span><br><span class="line">  String = <span class="string">"abc"</span> + <span class="string">'d'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍，活学活用，变通为宜。</p><hr><p><strong>作者：陶邦仁</strong><br><strong>链接：<a href="https://my.oschina.net/xianggao/blog/77224" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/77224</a></strong><br><strong>来源：开源中国</strong></p>]]></content>
    
    <summary type="html">
    
      都是细节
    
    </summary>
    
      <category term="Java" scheme="https://dolyw.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>怎么样写一个好的简历</title>
    <link href="https://dolyw.com/2019/04/20/2019-04-20-CV/"/>
    <id>https://dolyw.com/2019/04/20/2019-04-20-CV/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-05-16T12:51:23.948Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li>写简历首先要有一个好的模板，我们做技术的不同于UX，UED，我们不需要那么花哨，但是也需要整洁干净。好的模板能让你的简历给面试官一个好的印象，有一句话说得好，简单而不简单</li><li>回到技术上面，既然我们每天都用 <code>Markdown</code> 写文档，那么为什么直接用它编写我们的简历呢？清楚，简介，一目了然，方便存档和编辑</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>目前写简历的方式有两种普遍被认可，一种是STAR，一种是FAB</li></ul><blockquote><p>STAR法则，即为Situation Task Action Result的缩写，具体含义是: </p><blockquote><p>Situation: 事情是在什么情况下发生<br>Task: 你是如何明确你的任务的<br>Action: 针对这样的情况分析，你采用了什么行动方式<br>Result: 结果怎样，在这样的情况下你学习到了什么  </p></blockquote></blockquote><blockquote><p>FAB法则，即Feature Advantage Benefit的缩写，具体含义如下：  </p><blockquote><p>Feature：是什么<br>Advantage：比别人好在哪些地方<br>Benefit：如果雇佣你，招聘方会得到什么好处</p></blockquote></blockquote><ul><li>综上所述，无论是那种方式都是在用最简单明了的方式告诉别人你的工作，能力同时也体现了你的表达和总结能力。所以这个地方自己一定要反复推敲</li></ul><h2 id="规避"><a href="#规避" class="headerlink" title="规避"></a>规避</h2><ul><li>技术点，技术点描述不需要多而繁杂，不能乱入座，什么开发工具，写Tomcat，你怎么不说Java是操作系统呢 <em>PS: 大公司大多考虑的是领域深度，而不是很关心你是否为全栈</em></li><li>项目经历，时间倒序，项目不在于多，在于有亮点</li><li>反复检查和校验，切记马虎，切记马虎。切记错别字，切记错别字，切记错别字，笔者写简历的经理，检查几次以后还会有错别字。对于筛选简历的人是看到错别字，拼写错误是非常致命的，第一印象就是马虎</li><li>简单说明厉害即可，切勿长篇大论，没重点。你要考虑到每天筛查简历的人可能选择100多份</li><li>格式，不用花花绿绿，直接markdown即可，简洁并且有极客精神，如果喜欢其他格式尽量简洁明了，不需要把内容压缩到一页，赶紧整洁，让阅读者继续看就可以了 <em>PS: 网上的谬论说必须只能一页</em></li><li>尽量与众不同，面试者每天看很多简历，不要把自己简历写的自己觉得都什么亮点。如果特别没有亮点可以写一些自己遇到的问题，解决的问题，或者讲述一下自己理解的别人做的最好的设计方案</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><hr><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便）</p><ul><li>手机：132…. （如果是外地手机，可注明，如经常关机，要写上最优联系时间）</li><li>Email：<a href="mailto:dolyw6@gmail.com" target="_blank" rel="noopener">dolyw6@gmail.com</a> （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名）</li><li>QQ/微信号：6…（提供一个通过网络可以联系到你的方式）</li></ul><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul><li>随心/男/1997</li><li>火星计算机专业 </li><li>工作年限：3年</li><li>微博：<a href="http://weibo.com/dolyw" target="_blank" rel="noopener">@随风飘的纸飞机</a> （如果没有技术相关内容，也可以不放）</li><li>技术博客：<a href="https://blog.dolyw.com" target="_blank" rel="noopener">https://blog.dolyw.com</a> (使用GitHub Host Big较高)</li><li>Github：<a href="https://github.com/dolyw" target="_blank" rel="noopener">https://github.com/dolyw</a> (有原创repoGithub帐号会极大的提升你的个人品牌)</li><li>期望职位：Java高级程序员，应用架构师</li><li>期望薪资：税前月薪15k~20k，特别喜欢的公司可例外</li><li>期望城市：深圳</li></ul><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组）</p><h3 id="ABC公司-（20XX年XX月-20XX年XX月）"><a href="#ABC公司-（20XX年XX月-20XX年XX月）" class="headerlink" title="ABC公司 （20XX年XX月 ~ 20XX年XX月）"></a>ABC公司 （20XX年XX月 ~ 20XX年XX月）</h3><h4 id="DEF项目"><a href="#DEF项目" class="headerlink" title="DEF项目"></a>DEF项目</h4><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何</p><h4 id="GHI项目"><a href="#GHI项目" class="headerlink" title="GHI项目"></a>GHI项目</h4><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何</p><h4 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h4><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可）</p><h3 id="JKL公司-（20XX年XX月-20XX年XX月）"><a href="#JKL公司-（20XX年XX月-20XX年XX月）" class="headerlink" title="JKL公司 （20XX年XX月 ~ 20XX年XX月）"></a>JKL公司 （20XX年XX月 ~ 20XX年XX月）</h3><h4 id="MNO项目"><a href="#MNO项目" class="headerlink" title="MNO项目"></a>MNO项目</h4><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何</p><h4 id="PQR项目"><a href="#PQR项目" class="headerlink" title="PQR项目"></a>PQR项目</h4><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h4 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h4><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可）</p><h2 id="开源项目和作品"><a href="#开源项目和作品" class="headerlink" title="开源项目和作品"></a>开源项目和作品</h2><p>（这一段用于放置工作以外的、可证明你的能力的材料）</p><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>（对于程序员来讲，没有什么比Show me the code能有说服力了）</p><ul><li><a href="https://github.com/dolyw/ShiroJwt" target="_blank" rel="noopener">ShiroJwt</a>：项目的简要说明，Star和Fork数多的可以注明</li><li><a href="https://github.com/dolyw/ViewGenerator" target="_blank" rel="noopener">ViewGenerator</a>：项目的简要说明，Star和Fork数多的可以注明</li></ul><h3 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h3><p>（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）</p><ul><li><a href="https://blog.dolyw.com" target="_blank" rel="noopener">一个产品经理眼中的云计算：前生今世和未来</a></li><li><a href="https://blog.dolyw.com" target="_blank" rel="noopener">来自HeroKu的HTTP API 设计指南(翻译文章)</a> （好的翻译文章可以侧证你对英文技术文档的阅读能力）</li></ul><h3 id="演讲和讲义"><a href="#演讲和讲义" class="headerlink" title="演讲和讲义"></a>演讲和讲义</h3><p>（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）</p><ul><li>20XX架构师大会演讲：<a href="https://blog.dolyw.com" target="_blank" rel="noopener">如何通过Docker优化内部开发</a></li><li>X月公司内部分享：<a href="https://blog.dolyw.com" target="_blank" rel="noopener">云计算的前生今世</a></li></ul><h2 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h2><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p><ul><li>Web开发：Java/PHP/Hack/Node.js</li><li>Web框架：Spring/SpringCloud/ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li><li>前端框架：Bootstrap/Vue.js/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li><li>前端工具：Webpack/Bower/Gulp/SaSS/LeSS/PhoneGap</li><li>数据库相关：MySQL/PgSQL/PDO/SQLite</li><li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li><li>单元测试：PHPUnit/SimpleTest/Qunit</li><li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li></ul><p>（当然你也可以这样写）</p><ul><li>熟悉Java/Node.js/PHP/Python/C++/C的拼写</li><li>了解Ubuntu/Alpine/macOS的开关机方式</li><li>精通Docker的pull和push</li><li>注册GitHub帐号并且刷了一些Star</li></ul><hr><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><strong>感谢您花时间阅读我的简历，期待能有机会和您共事</strong></p>]]></content>
    
    <summary type="html">
    
      怎么样写一个好的简历
    
    </summary>
    
      <category term="InterviewCV" scheme="https://dolyw.com/categories/InterviewCV/"/>
    
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
      <category term="InterviewCV" scheme="https://dolyw.com/tags/InterviewCV/"/>
    
  </entry>
  
  <entry>
    <title>面试题收集</title>
    <link href="https://dolyw.com/2019/04/20/2019-04-20-Interview/"/>
    <id>https://dolyw.com/2019/04/20/2019-04-20-Interview/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-05-16T12:44:08.188Z</updated>
    
    <content type="html"><![CDATA[<hr><ol><li><p>自我介绍（主要讲自己会的技术细节，项目经验，经历那些就一语带过，后面面试官会问你的）</p></li><li><p>聊聊项目（就是一个很普通的分布式商城，自己做了一些改进），让我画了整个项目的架构图，然后针对项目抛了一系列的提高性能的问题，还问了我做项目的过程中遇到了那些问题，如何解决的，差不读就这些吧</p></li><li><p>可能是我前面说了我会数据库优化，然后面试官就开始问索引、事务隔离级别、悲观锁和乐观锁、索引、ACID、MVVC这些问题</p></li><li><p>浏览器输入URL发生了什么? TCP和UDP区别? TCP如何保证传输可靠性?</p></li><li><p>讲下跳表怎么实现的?哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树</p></li><li><p>后面又问了很多JVM方面的问题，比如Java内存模型、常见的垃圾回收器、双亲委派模型这些</p></li><li><p>你有什么问题要问吗？</p></li></ol><hr><ol start="2"><li><p>操作系统的内存管理机制</p></li><li><p>进程和线程的区别</p></li><li><p>说下你对线程安全的理解</p></li><li><p>volatile有什么作用，sychronized和lock有什么区别</p></li><li><p>ReentrantLock实现原理</p></li><li><p>用过CountDownLatch么？什么场景下用的？</p></li><li><p>AQS底层原理</p></li><li><p>造成死锁的原因有哪些，如何预防？</p></li><li><p>加锁会带来哪些性能问题。如何解决？</p></li><li><p>HashMap、ConcurrentHashMap源码。HashMap是线程安全的吗？Hashtable呢？ConcurrentHashMap有了解吗？</p></li><li><p>你有什么问题要问吗？</p></li></ol><hr><ol start="3"><li><p>你觉得你有什么优点和缺点？你觉得你相比于那些比你更优秀的人欠缺什么？</p></li><li><p>有读过什么源码吗？（我说我读过 Java 集合框架和 Netty 的，面试官说 Java 集合前几面一定问的差不多，就不问了，然后就问我 Netty的，我当时很慌啊！）</p></li><li><p>介绍一下自己对 Netty 的认识，为什么要用。说说业务中，Netty 的使用场景。什么是TCP 粘包/拆包,解决办法。Netty线程模型。Dubbo 在使用 Netty 作为网络通讯时候是如何避免粘包与半包问题？讲讲Netty的零拷贝？</p></li><li><p>用到了那些开源技术、在开源领域做过贡献吗？</p></li><li><p>常见的排序算法及其复杂度，现场写了快排</p></li><li><p>红黑树，B树的一些问题</p></li><li><p>讲讲算法及数据结构在实习项目中的用处</p></li><li><p>自己的未来规划（就简单描述了一下自己未来的设想啊，说的还挺诚恳，面试官好像还挺满意的）</p></li><li><p>你有什么问题要问吗？</p></li></ol><hr><ol><li><p>让我讲一个自己觉得最不错的项目。然后就巴拉巴拉的聊，我记得主要是问了项目是如何进行协作的、遇到问题是如何解决的、与他人发生冲突是如何解决的这些。感觉聊了挺久</p></li><li><p>出现 OOM 后你会怎么排查问题？</p></li><li><p>自己平时是如何学习新技术的？除了 Java 还回去了解其他技术吗?</p></li><li><p>上一段工作经历的收获</p></li><li><p>NginX如何做负载均衡、常见的负载均衡算法有哪些、一致性哈希的一致性是什么意思、一致性哈希是如何做哈希的</p></li><li><p>你有什么问题问我吗？</p></li></ol><hr><ol><li><p>自我介绍（主要讲能突出自己的经历，会的编程技术一语带过）</p></li><li><p>你觉得你有什么优点和缺点？如何克服这些缺点？</p></li><li><p>你前面跟其他面试官讲过一些你做的项目吧？可以给我讲讲吗？你要考虑到我不是一个做技术的人，怎么让我也听得懂。项目中有什么问题，你怎么解决的？你最大的收获是什么？</p></li><li><p>你目前有面试过其他公司吗？如果让你选，这些公司和我们公司，你选哪个？（送分题，回答不好可能送命）</p></li><li><p>你期望的工作地点是哪里？</p></li><li><p>你有什么问题吗？</p></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>可以看出面试官问的很多问题都是比较常见的问题，所以记得一定要提前准备，还要深入准备，不要回答的太皮毛。很多时候一个问题可能会牵扯出很多问题，遇到不会的问题不要慌，冷静分析，如果你真的回答不上来，也不要担心自己是不是就要挂了，很可能这个问题本身就比较难。</p></li><li><p>表达能力和沟通能力太重要了，一定要提前练一下，我自身就是一个不太会说话的人，所以，面试前我对于自我介绍、项目介绍和一些常见问题都在脑子里练了好久，确保面试的时候能够很清晰和简洁的说出来</p></li><li><p>面试之后及时总结，面的好的话，不要得意，尽快准备下一场面试吧</p></li></ol>]]></content>
    
    <summary type="html">
    
      面试题收集
    
    </summary>
    
      <category term="InterviewCV" scheme="https://dolyw.com/categories/InterviewCV/"/>
    
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
      <category term="InterviewCV" scheme="https://dolyw.com/tags/InterviewCV/"/>
    
  </entry>
  
  <entry>
    <title>史上最污技术解读，让你秒懂IT术语</title>
    <link href="https://dolyw.com/2019/03/18/2019-03-18-Technical-Interpretation/"/>
    <id>https://dolyw.com/2019/03/18/2019-03-18-Technical-Interpretation/</id>
    <published>2019-03-18T07:18:18.000Z</published>
    <updated>2019-05-16T11:32:24.787Z</updated>
    
    <content type="html"><![CDATA[<hr><p>假设你是一位妹子，你的男友沉迷游戏经常不接电话无故宕机，所以当你们约好下午逛街以后你要时不时地打个电话询问，看看他是不是还能正常提供服务，这叫<strong>心跳检测</strong>。</p><p>假设你是一位妹子，你想去逛街而你的男友A在打游戏不接电话，于是乎你把逛街的请求发给了替补男友B，从而保障服务不间断运行，这叫<strong>故障切换</strong>。</p><p>假设你是一位妹子，你有很多需要男朋友完成的事情，于是乎你跟A逛街旅游吃饭不可描述，而B只能陪你逛街，不能拥有全部男朋友的权利，这叫<strong>主从配置</strong> <strong>master-slave</strong>。</p><p>假设你是一位妹子，你的需求太强烈以至于你的男友根本吃不消，于是乎你找了两个男朋友，一三五单号，二四六双号限行，从而减少一个男朋友所面临的压力，这叫<strong>负载均衡</strong>。</p><p>假设你是一位妹子，并且有多个男朋友，配合心跳检测与故障切换和负载均衡将会达到极致的体验，这叫<strong>集群LVS</strong>。注意，当需求单机可以处理的情况下不建议启用集群，会造成大量资源闲置，提高维护成本。</p><p>假设你是一位妹子，你的需求越来越高导致一个男朋友集群已经处理不了了，于是乎你又新增了另外几个，这叫<strong>多集群横向扩容</strong>，简称<strong>multi-cluster grid</strong>。</p><p>假设你是一位妹子，你的男朋友身体瘦弱从而无法满足需求，于是乎你买了很多大补产品帮你男朋友升级，从而提高单机容量，这叫<strong>纵向扩容</strong>。切记，纵向扩容的成本会越来越高而效果越来越不明显。</p><p>假设你是一位妹子，你跟男友经常出去游玩，情到深处想做点什么的时候却苦于没有tt，要去超市购买，于是乎你在你们经常去的地方都放置了tt，从而大幅度降低等待时间，这叫<strong>CDN</strong>。</p><p>假设你是一位妹子，你的男朋友英俊潇洒风流倜傥财大气粗对你专一，于是乎你遭到了女性B的敌视，B会以朋友名义在周末请求你男朋友修电脑、修冰箱，占用男朋友大量时间，造成男朋友无法为你服务，这叫<strong>拒绝服务攻击</strong>，简称<strong>DOS</strong>。</p><p>假设你是一位妹子，你因男朋友被一位女性敌视，但是你男朋友的处理能力十分强大，处理速度已经高于她的请求速度，于是她雇佣了一票女性来轮流麻烦你的男朋友，这叫<strong>分布式拒绝服务攻击</strong>，简称<strong>DDOS</strong>。</p><p>假设你是一位妹子，你发现男朋友总是在处理一些无关紧要的其它请求，于是乎你给男朋友列了一个白名单，要求他只处理白名单内的请求，而拒绝其它身份不明的人的要求，这叫<strong>访问控制</strong>，也叫<strong>会话跟踪</strong>。</p><p>假设你是一位妹子，你发现采取上述措施以后男朋友的处理请求并没有减少很多，于是你经过调查发现，有人伪造你的微信头像、昵称来向你的男朋友发起请求，这叫<strong>跨站点请求伪造</strong>，简称<strong>CSRF</strong>。</p><p>假设你是一位妹子，你收到了一份快递，于是你要求男朋友给你取快递，当你拿到快递以后发现有人给你邮寄了一封通篇辱骂的信件，这叫<strong>跨站点脚本攻击</strong>，简称<strong>XSS</strong>。请注意，对方完全可以给你邮寄微型窃听器来窃听你的隐私。</p><p>假设你是一位妹子，为了应对威胁，你要求你的男朋友对邮寄给你的邮件必须检查，这叫<strong>数据校验与过滤</strong>。</p><p>假设你是一位妹子，你的男朋友太优秀而遭人窥视，于是乎他们研究了一下你的男朋友，稍微修改了一点点生产出一个男朋友B，与你的男朋友百分之99相似，这不叫剽窃，这叫<strong>逆向工程</strong>，比如男朋友<strong>外挂</strong>。</p><p>假设你是一位妹子，你要求你的男朋友坚持十分钟，然后十五分钟继而二十分钟以测试你男朋友的极限在哪里，这叫<strong>压力测试</strong>。压力测试的目的是查看男朋友是否可以处理需求从而决定是否启用男朋友集群或提升男朋友处理能力，不要对线上运行的男朋友做压力测试，可能会造成宕机的后果，会血本无归的。</p><p>假设你是一位妹子，为了保证你男朋友的正常运行，于是乎你每天查看他的微信微博等社交资料来寻找可能产生问题的线索，这叫<strong>数据分析</strong>。</p><p>假设你是一位妹子，你的男朋友属于社交活跃选手，每天的微博知乎微信生产了大量信息，你发现自己的分析速度远远低于他生产的速度，于是乎你找来你的闺蜜一起分析，这叫<strong>并行计算</strong>。</p><p>假设你是一位妹子，你的男朋友太能折腾处处留情产生了天量的待处理信息，你和你的闺蜜们已经累趴也没赶上他创造的速度，于是你付费在知乎上找了20个小伙伴帮你一起分析，这叫<strong>云计算</strong>。</p><p>假设你是一位妹子，在使用云计算后获得了大量整理好的男朋友数据，这些数据如下</p><table><thead><tr><th>地点</th><th>活跃时间段</th><th>活跃次数</th></tr></thead><tbody><tr><td> 如家</td><td>xxxx</td><td>123次 </td></tr><tr><td> 汉庭</td><td>xxxx</td><td>45次              </td></tr><tr><td> …</td><td>…</td><td>…</td><td></td></tr></tbody></table><p>这叫<strong>数据统计</strong>。</p><p>假设你是一位妹子，你在得到男朋友经常出没的地点后，根据酒店、敏感时间段等信息确定男朋友应该是出轨了，这叫<strong>数据挖掘</strong>。</p><p>假设你是一位妹子，在分析男友的数据后，得知他下午又要出去开房，于是乎你在他准备出门前给他发了个短信，问他有没有带tt，没有的话可以在我这里买，这叫<strong>精准推送</strong>，需要配合数据挖掘。</p><p>假如你是一位妹子，你的男朋友总出去浪而各种出问题，于是乎你租了间屋子并准备好了所有需要的东西并告诉他，以后不用找酒店了，直接来我这屋子吧，什么都准备好了，这叫<strong>容器</strong>。</p><p>假如你是一位妹子，你每天都要和男朋友打通一次接口，这叫<strong>采集数据</strong>。你的男朋友用来连接你和他的工具，叫做<strong>接口“机”</strong>，你采集到的数据叫做<strong>“流”数据</strong>。你一天24小时不停地采，这叫<strong>实时数据采集</strong>。你决定开发新的接口来和男朋友交流，这叫<strong>虚拟化</strong>。你决定从不同的男友身上采集数据，你就是<strong>大数据中心</strong>。有一天你决定生一个宝宝，这叫<strong>大数据应用</strong>。宝宝生下来不知道是谁的，这叫<strong>大数据脱敏</strong>。但是从宝宝外观来看，黑色皮肤金色头发，这叫<strong>数据融合跨域建模</strong>。你决定把这个宝宝拿来展览收点门票，这叫<strong>大数据变现</strong>。</p><hr><p><strong>作者：我傻笑你跑掉</strong><br><strong>链接：<a href="https://www.zhihu.com/question/263789393/answer/274245200" target="_blank" rel="noopener">https://www.zhihu.com/question/263789393/answer/274245200</a></strong><br><strong>来源：知乎</strong></p>]]></content>
    
    <summary type="html">
    
      太污了，纯洁的我都看不下去了
    
    </summary>
    
      <category term="Java" scheme="https://dolyw.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>别让遗憾聚集到最后无法挽回，让所有的想念启程</title>
    <link href="https://dolyw.com/2019/01/31/2019-01-31-Do-Not-Regret-His/"/>
    <id>https://dolyw.com/2019/01/31/2019-01-31-Do-Not-Regret-His/</id>
    <published>2019-01-31T06:20:18.000Z</published>
    <updated>2019-05-16T12:34:10.845Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/01.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/02.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/03.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/04.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/05.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/18.gif" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/06.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/19.gif" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/07.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/08.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/09.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/10.png" width="500px"></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/11.png" width="500px"></p><hr><p><strong>曾经有人这样比喻过时间，人生可以划成900个小个子，每个格子代表一个月，假设每个人能活到75岁。</strong></p><p><strong>如果你今年20岁，那么黄色代表你用掉的时间，剩下空白是你还拥有的时间：</strong></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/12.png" width="500px"></p><p><strong>如果你今年已经30岁，你的人生空白还剩这么多：</strong></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/13.png" width="500px"></p><p><strong>假设我们的父母，平均年龄是50岁，他们的人生已经走过这么多：</strong></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/14.png" width="500px"></p><p><strong>假设你和父母天天见面，你们拥有彼此的时间是这么多：</strong></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/15.png" width="500px"></p><p><strong>如果半个月见一次，你们的时间是这样的：</strong></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/16.png" width="500px"></p><p><strong>如果一年见一次，时间还剩下…..</strong></p><p><img src="https://dolyw.gitee.io/reader/Image/Docs/20190131/17.png" width="500px"></p><p><strong>这个世界上，最公平的就是时间，</strong></p><p><strong>你选择怎么涂满这900个方格全在你自己。</strong></p><hr><p><strong>这一生，你大约会遇见80000人，这些人都曾跟你有过一面之缘。</strong></p><p><strong>有的人走近了你，嵌入生命；</strong></p><p><strong>有的人与你擦肩而过，山水不相逢；</strong></p><p><strong>有的人来过，爱过，最后错过。</strong></p><p><strong>长大后发现，很多下次再见，就是再也不见。</strong></p><p><strong>别让爱你的人成为通讯里一个号码，朋友圈里的一个点赞。</strong></p><p><strong>别让遗憾聚集到最后无法挽回，让所有的想念启程。</strong></p><p><strong>让他和她看到这篇文章，代替你说出那句</strong></p><p><strong>我想你了。</strong></p><hr><p><strong>作者：春丽 情商夜读</strong><br><strong>链接：<a href="https://mp.weixin.qq.com/s/X4MR_tT0d9TUkU5Ep96rqQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/X4MR_tT0d9TUkU5Ep96rqQ</a></strong><br><strong>来源：微信</strong></p>]]></content>
    
    <summary type="html">
    
      有的人走近了你，嵌入生命；有的人与你擦肩而过，山水不相逢；有的人来过，爱过，最后错过。长大后发现，很多下次再见，就是再也不见
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程池的创建及使用</title>
    <link href="https://dolyw.com/2019/01/18/2019-01-18-Thread-Pool/"/>
    <id>https://dolyw.com/2019/01/18/2019-01-18-Thread-Pool/</id>
    <published>2019-01-18T07:18:18.000Z</published>
    <updated>2019-05-16T12:32:06.032Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="合理利用线程池能够带来三个好处"><a href="#合理利用线程池能够带来三个好处" class="headerlink" title="合理利用线程池能够带来三个好处"></a>合理利用线程池能够带来三个好处</h3><ul><li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="线程池的处理流程如下"><a href="#线程池的处理流程如下" class="headerlink" title="线程池的处理流程如下"></a>线程池的处理流程如下</h3><ol><li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程</li><li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程</li><li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务。满了，则交给饱和策略来处理这个任务</li></ol><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我们可以通过ThreadPoolExecutor来创建一个线程池</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/18 17:38</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue, threadFactory, handler);</span><br></pre></td></tr></table></figure><ul><li>参数介绍</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize - 线程池核心池的大小</span><br><span class="line">maximumPoolSize - 线程池的最大线程数</span><br><span class="line">keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间</span><br><span class="line">unit - keepAliveTime的时间单位</span><br><span class="line">workQueue - 用来储存等待执行任务的队列</span><br><span class="line">threadFactory - 线程工厂</span><br><span class="line">handler - 拒绝策略</span><br></pre></td></tr></table></figure><h3 id="线程池不允许使用Executors去创建"><a href="#线程池不允许使用Executors去创建" class="headerlink" title="线程池不允许使用Executors去创建"></a>线程池不允许使用Executors去创建</h3><ul><li>线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</li></ul><h4 id="Executors各个方法的创建线程池的弊端"><a href="#Executors各个方法的创建线程池的弊端" class="headerlink" title="Executors各个方法的创建线程池的弊端"></a>Executors各个方法的创建线程池的弊端</h4><ul><li><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>的主要问题是堆积的请求处理队列可能会耗费非常大的内存</li><li><code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>的主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程</li></ul><h3 id="线程池创建方式-根据阿里巴巴Java开发规范，推荐了3种线程池创建方式"><a href="#线程池创建方式-根据阿里巴巴Java开发规范，推荐了3种线程池创建方式" class="headerlink" title="线程池创建方式(根据阿里巴巴Java开发规范，推荐了3种线程池创建方式)"></a>线程池创建方式(根据阿里巴巴Java开发规范，推荐了3种线程池创建方式)</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 需要引入commons-lang3</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/18 17:49</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">"example-schedule-pool-%d"</span>).daemon(<span class="keyword">true</span>).build());</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 需要引入com.google.guava</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/18 17:49</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"><span class="comment">// Common Thread Pool</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line"><span class="comment">// gracefully shutdown</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><ul><li>推荐工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 需要引入com.google.guava</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/18 17:56</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile定义executorService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁止实例化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.util.concurrent.ExecutorService</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019/3/18 11:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadPoolUtil.class) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * ThreadPoolExecutor参数解释</span></span><br><span class="line"><span class="comment">                 * 1. corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">                 * 2. maximumPoolSize 线程池最大容量大小</span></span><br><span class="line"><span class="comment">                 * 3. keepAliveTime 线程池空闲时，线程存活的时间</span></span><br><span class="line"><span class="comment">                 * 4. TimeUnit 时间单位</span></span><br><span class="line"><span class="comment">                 * 5. BlockingQueue 任务队列</span></span><br><span class="line"><span class="comment">                 * 6. ThreadFactory 线程工厂</span></span><br><span class="line"><span class="comment">                 * 7. RejectedExecutionHandler 线程拒绝策略</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line">                executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0L</span>, </span><br><span class="line">                        TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), </span><br><span class="line">                        namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><ul><li>Spring配置线程池方式：自定义线程工厂Bean需要实现ThreadFactory，使用方式直接注入Bean后使用</li><li>代码</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userThreadPool"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"threadFactory"</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rejectedExecutionHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"rejectedExecutionHandler"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">// in code</span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>ThreadPoolExecutor线程池不允许使用Executors创建:<a href="https://blog.csdn.net/fly910905/article/details/81584675" target="_blank" rel="noopener">https://blog.csdn.net/fly910905/article/details/81584675</a></li></ol><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><ol><li>为什么不推荐通过Executors直接创建线程池:<a href="https://blog.csdn.net/u010321349/article/details/83927012" target="_blank" rel="noopener">https://blog.csdn.net/u010321349/article/details/83927012</a></li><li>ThreadPoolExecutor使用详解:<a href="https://www.cnblogs.com/zedosu/p/6665306.html" target="_blank" rel="noopener">https://www.cnblogs.com/zedosu/p/6665306.html</a></li><li>Java并发编程线程池的使用:<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      简单的介绍在Java中的线程池的创建及使用
    
    </summary>
    
      <category term="Thread" scheme="https://dolyw.com/categories/Thread/"/>
    
    
      <category term="Thread" scheme="https://dolyw.com/tags/Thread/"/>
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>List集合去重方式及效率对比</title>
    <link href="https://dolyw.com/2019/01/17/2019-01-17-List-De-Duplication/"/>
    <id>https://dolyw.com/2019/01/17/2019-01-17-List-De-Duplication/</id>
    <published>2019-01-17T07:18:18.000Z</published>
    <updated>2019-05-16T12:31:52.430Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><code>List</code>集合相信大家在开发过程中几乎都会用到。有时候难免会遇到集合里的数据是重复的，需要进行去除。然而，去重方式有好几种方式，你用的是哪种方式呢？去重方式效率是否是最高效、最优的呢？今天就给大家讲解一下<code>List</code>集合去重的常见及常用的四种方式</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><h4 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h4><ul><li>使用两个<code>for</code>循环遍历集合所有元素，然后进行判断是否有相同元素，如果有，则去除。这种方式是大部分最先想到的，也是最简单的实现方式。其中，这种方式可以保证<code>List</code>集合原来的顺序不变</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用两个for循环实现List去重</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/17 18:08</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">repeatListWayOne</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (list.get(i).equals(list.get(j))) &#123;</span><br><span class="line">               list.remove(j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h4><ul><li>我们知道<code>HashSet</code>实现了<code>Set</code>接口，不允许出现重复元素。可以基于这个想法，把<code>List</code>集合所有元素存入<code>HashSet</code>对象，接着把<code>List</code>集合元素全部清空，最后把<code>HashSet</code>对象元素全部添加至<code>List</code>集合中，这样就可以保证不出现重复元素。而<code>HashSet</code>有一个构造函数，在初始化时可以直接添加元素。其中，<code>HashSet</code>不能保证顺序不变，所以此方式不能保证<code>List</code>集合原来的顺序不变</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用HashSet实现List去重</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/17 18:08</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">repeatListWayTwo</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化HashSet对象，并把list对象元素赋值给HashSet对象</span></span><br><span class="line">  HashSet set = <span class="keyword">new</span> HashSet(list);</span><br><span class="line">  <span class="comment">// 把List集合所有元素清空</span></span><br><span class="line">  list.clear();</span><br><span class="line">  <span class="comment">// 把HashSet对象添加至List集合</span></span><br><span class="line">  list.addAll(set);</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h4><ul><li><code>TreeSet</code>集合也是实现<code>Set</code>接口，是一个有序的，并且无重复元素集合。同理，我们可以根据上面方式二的思想进行去重。其中，去重后的<code>List</code>集合可以保证和原来的顺序一致</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用TreeSet实现List去重</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/17 18:08</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">repeatListWayThird</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化TreeSet对象，并把list对象元素赋值给TreeSet对象</span></span><br><span class="line">   TreeSet set = <span class="keyword">new</span> TreeSet(list);</span><br><span class="line">   <span class="comment">// 把List集合所有元素清空</span></span><br><span class="line">   list.clear();</span><br><span class="line">   <span class="comment">// 把TreeSet对象添加至List集合</span></span><br><span class="line">   list.addAll(set);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式四"><a href="#实现方式四" class="headerlink" title="实现方式四"></a>实现方式四</h4><ul><li>利用<code>List</code>集合<code>contains</code>方法循环遍历，先创建新的<code>List</code>集合，接着循环遍历原来的<code>List</code>集合，判断新集合是否包含有旧集合，如果有，则不添加至新集合，否则添加。最后，把旧集合清空，把新集合元素赋值给旧集合</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 利用List集合contains方法循环遍历去重</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> dolyw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/1/17 18:08</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">repeatListWayFourth</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 新建新List集合，用于存放去重后的元素</span></span><br><span class="line">   List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   <span class="comment">// 循环遍历旧集合元素</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ ) &#123;</span><br><span class="line">       <span class="comment">// 判断新集合是否包含有，如果不包含有，则存入新集合中</span></span><br><span class="line">       <span class="keyword">boolean</span> isContains = newList.contains(list.get(i));</span><br><span class="line">       <span class="keyword">if</span>(!isContains) &#123;</span><br><span class="line">           newList.add(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 把List集合所有元素清空</span></span><br><span class="line">   list.clear();</span><br><span class="line">   <span class="comment">// 把新集合元素添加至List集合</span></span><br><span class="line">   list.addAll(newList);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><ul><li>上面给大家介绍了四种List集合去重方式。那么，哪种方式效率是最好的呢？下面就演示一下进行对比</li><li>为了演示方式，随机生成0-500之间的20000个整数字符串，并存入List集合，并在相应代码打印相关时间进行对比。其中，随机生成List集合代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getRandomList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   <span class="comment">// 随机生成20000个整数字符串</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20000</span>; i++) &#123;</span><br><span class="line">       <span class="comment">// 任意取[0,500)之间整数，其中0可以取到，500取不到</span></span><br><span class="line">       <span class="keyword">int</span> number = <span class="keyword">new</span> Random().nextInt(<span class="number">500</span>);</span><br><span class="line">       String number_str = <span class="string">"geshan"</span> + number;</span><br><span class="line">       list.add(number_str);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了保证List集合元素一致，创建四个List集合，分别对应List去重方式。效率对比代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 随机生成0-500之间的1000个整数字符串List集合</span></span><br><span class="line">   List&lt;String&gt; list = getRandomList();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 为了演示四种方式效率，创建四个List集合，保证List集合元素一致</span></span><br><span class="line">   <span class="comment">// 方式一List集合</span></span><br><span class="line">   List&lt;String&gt; oneList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   oneList.addAll(list);</span><br><span class="line">   <span class="comment">// 方式二List集合</span></span><br><span class="line">   List&lt;String&gt; twoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   twoList.addAll(list);</span><br><span class="line">   <span class="comment">// 方式三List集合</span></span><br><span class="line">   List&lt;String&gt; thirdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   thirdList.addAll(list);</span><br><span class="line">   <span class="comment">// 方式四List集合</span></span><br><span class="line">   List&lt;String&gt; fourthList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   fourthList.addAll(list);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"方式一：使用两个for循环实现List去重"</span>);</span><br><span class="line">   System.out.println(<span class="string">"原来集合大小:"</span> + oneList.size() + <span class="string">"，集合元素&gt;&gt;"</span> + oneList);</span><br><span class="line">   Date oneDateBegin = <span class="keyword">new</span> Date();</span><br><span class="line">   repeatListWayOne(oneList);</span><br><span class="line">   System.out.println(<span class="string">"集合去重大小:"</span> + oneList.size()+<span class="string">"，集合元素&gt;&gt;"</span> + oneList);</span><br><span class="line">   Date oneDateEnd = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">"去重所需时间:"</span> + (oneDateEnd.getTime() - oneDateBegin.getTime()) + <span class="string">"毫秒"</span>);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"方式二：使用HashSet实现List去重"</span>);</span><br><span class="line">   System.out.println(<span class="string">"原来集合大小:"</span> + twoList.size() + <span class="string">"，集合元素&gt;&gt;"</span> + twoList);</span><br><span class="line">   Date twoDateBegin = <span class="keyword">new</span> Date();</span><br><span class="line">   repeatListWayTwo(twoList);</span><br><span class="line">   System.out.println(<span class="string">"集合去重大小:"</span> + twoList.size() + <span class="string">"，集合元素&gt;&gt;"</span> + twoList);</span><br><span class="line">   Date twoDateEnd = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">"去重所需时间:"</span> + (twoDateEnd.getTime() - twoDateBegin.getTime()) + <span class="string">"毫秒"</span>);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"方式三：使用TreeSet实现List去重"</span>);</span><br><span class="line">   System.out.println(<span class="string">"原来集合大小:"</span> + thirdList.size() + <span class="string">"，集合元素&gt;&gt;"</span> + thirdList);</span><br><span class="line">   Date thirdDateBegin = <span class="keyword">new</span> Date();</span><br><span class="line">   repeatListWayThird(thirdList);</span><br><span class="line">   System.out.println(<span class="string">"集合去重大小:"</span> + thirdList.size() + <span class="string">"，集合元素&gt;&gt;"</span> + thirdList);</span><br><span class="line">   Date thirdDateEnd = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">"去重所需时间:"</span> + (thirdDateEnd.getTime() - thirdDateBegin.getTime()) + <span class="string">"毫秒"</span>);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"方式四：利用List集合contains方法循环遍历去重"</span>);</span><br><span class="line">   System.out.println(<span class="string">"原来集合大小:"</span> + fourthList.size()+<span class="string">"，集合元素&gt;&gt;"</span> + fourthList);</span><br><span class="line">   Date fourthDateBegin = <span class="keyword">new</span> Date();</span><br><span class="line">   repeatListWayFourth(fourthList);</span><br><span class="line">   System.out.println(<span class="string">"集合去重大小:"</span> + fourthList.size()+<span class="string">"，集合元素&gt;&gt;"</span> + fourthList);</span><br><span class="line">   Date fourthDateEnd = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">"去重所需时间:"</span> + (fourthDateEnd.getTime() - fourthDateBegin.getTime()) + <span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多次运行结果如下"><a href="#多次运行结果如下" class="headerlink" title="多次运行结果如下"></a>多次运行结果如下</h4><ul><li>第一次四种方式运行时间如下：223、10、16、30(ms)  </li><li>第二次四种方式运行时间如下：164、10、17、43(ms)  </li><li>第三次四种方式运行时间如下：164、9、16、37(ms)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>综合代码及运行时间对比，方式二是最好的去重方式，代码最简洁、耗时最短，不过无法保证顺序，需要保证顺序一致可以采用方式三</li></ul>]]></content>
    
    <summary type="html">
    
      简单的介绍在Java中的List集合去重方式及效率对比
    
    </summary>
    
      <category term="Java" scheme="https://dolyw.com/categories/Java/"/>
    
    
      <category term="List" scheme="https://dolyw.com/tags/List/"/>
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>万般滋味，都是生活</title>
    <link href="https://dolyw.com/2018/12/31/2018-12-31-Tastes-Are-Life/"/>
    <id>https://dolyw.com/2018/12/31/2018-12-31-Tastes-Are-Life/</id>
    <published>2018-12-31T13:46:18.000Z</published>
    <updated>2019-05-16T12:31:47.412Z</updated>
    
    <content type="html"><![CDATA[<hr><p>有人住高楼，有人在深沟，</p><p>有人光万丈，有人一身锈。</p><p>有人靠一张脸，一部片子能挣1000万，</p><p>有人仅仅活着，就已经用尽全身力气。</p><p>可是他们，面对命运的青脸獠牙，</p><p>依然慨当以慷，微笑面对。</p><hr><p>成年人的生活没有容易二字，</p><p>同样没有迈不过去的槛。</p><p>要相信，所有的难过，再难也会过。</p><p>这世界上有很多寒冷，侵入骨髓，</p><p>但也有很多温暖，让人留恋。</p><p>世界不好也不坏，总有人悄悄爱着你。</p><p>生活虽然不易，但希望从未远离。</p><hr><p>如果恰巧你被生活戏弄，</p><p>那就配合的哈哈大笑一声，</p><p>我与命运抗争过，没什么大不了。</p><p>拥有一个温暖的家，何尝不是人生的圆满和幸福。</p><p>无论什么时候，都不要悲愤，更不要仇恨。</p><p>这个世界从来都不欠你什么。</p><p>真正优秀的人，没有时间去抱怨，</p><p>他们都把时间用在了拼命努力上。</p><p>大部分负重前行的平凡人，</p><p>都知道前路艰难，但无路可退。</p><hr><p>做一个努力的人好处在于，</p><p>人家见了你都会想帮你。</p><p>如果你自己不做出一点努力的样子，</p><p>人家想拉你一把，都不知你的手在哪里。</p><p>万般滋味，都是生活。</p><p>愿你出走半生，仍是少年。</p><hr><p><strong>作者：无名</strong><br><strong>来源：微信</strong></p>]]></content>
    
    <summary type="html">
    
      有人住高楼，有人在深沟，有人光万丈，有人一身锈。有人靠一张脸，一部片子能挣1000万，有人仅仅活着，就已经用尽全身力气...
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>物是人非，感谢你们曾经繁华了我的青春</title>
    <link href="https://dolyw.com/2018/12/07/2018-12-07-Thank-You/"/>
    <id>https://dolyw.com/2018/12/07/2018-12-07-Thank-You/</id>
    <published>2018-12-07T09:46:18.000Z</published>
    <updated>2019-05-16T12:31:44.215Z</updated>
    
    <content type="html"><![CDATA[<hr><p>同学聚会，原本我是打算要去的，但看了一下参加的只有10个人，觉得有点难过，就决定不去了。</p><p>近50人的班级，能参加聚会的一年比一年少，见过大家围成一圈坐在足球场不用说话也十分美好的场景，我忍受不了最后能看到的他们只有六分之一。</p><p>女朋友也参加了同学聚会，可是她并不开心。有的打麻将，有的斗地主，有的喝酒，就她一个人烤火，显得很不合群。</p><p>她说她咳嗽流鼻涕打喷嚏很不舒服，而且实在太无聊了，只能玩玩手机，问我一个人在家无聊吗？我说无聊我可以玩吃鸡游戏，你要多喝水。</p><p>今年是我高中毕业十年，以为会有一次大的聚会。但似乎没有人放在心上，毕竟大家毕业时抱头痛哭，这辈子天涯海角都是兄弟的誓言，早就忘得一干二净了。</p><p>那些年，我们觉得世界很小，各奔东西后才知，一别也许就是一世。后来纵然能聚，大家说着交际的话，喝着应酬的酒，带着应付的笑，却再也走不进彼此的心。</p><p>同学聚会筛掉了飞得高的，走得远的，混得惨的，性格刚的。最后剩下的只有同一坐标系里的同学，每年相互确认，原来你过得还是这个样子。</p><hr><p>有人说，同学聚会都有一个规律，凡是以前老实本分、循规蹈矩的同学基本混得不怎样，窝在某个城市的某个单位拿着一个月几千的固定工资。</p><p>凡是以前经常惹点小麻烦，让班主任头疼过的，基本在社会上混得都比较好，有房有车有老婆有小三，一般都是老板，可以驾驭别人。</p><p>其实这句话我不是很赞同，因为那些曾经让班主任头疼而毫无作为的人，可能只是没来参加同学聚会而已。人生哪有那么滑稽，随便混混也能出人头地。</p><p>当你还是一个在校学生的时候，学校和老师帮你定位身份，指明方向，你顺着走不一定会走得舒服，但是一定不会走歪。毕业之后没有外挂和辅助，一些人就迷茫了，不知道该往哪里走，甚至先迈哪条腿都犹豫不决。</p><p>大家对彼此的了解，大多时候只是表面上的，背地里谁努力，谁偷懒，谁知行合一，谁三天打鱼两天晒网，在学生时代体现身份价值的只有纸面上的成绩。进入社会后，能够实战，体现自己价值的地方更多了。</p><p>像是跳一跳，每一次都正对中心点，一环变两环，两环变四环，走得准走得稳更有走得狠的，都走向了人生巅峰。对于同学聚会，有些人不屑参加，有些人羞于参加。能去的，几乎每一个人都有一个特定的社会身份，会让你觉得他和学生时期差异比较大。</p><hr><p>一个班或者一个专业的同学，就像一批人凝结成了一滴墨水，毕业后滴到社会的海里。波涛涌动循环往复，三五年后，墨水极度稀释，分散在不同位置。</p><p>也许每个人的追求不同，但从缩短差距上来说，一毕业就去“养老”型的公司的人，会被周围不甘平凡的同学逐渐拉开。人这一辈子，吃多少苦，享多少福，存在一个动态平衡。 </p><p>去“养老”公司和去上升期的公司，人的工作状态完全不一样，获得技能包的量当然也天壤之别。更重要的是，后者很可能已步入中层，在技术和管理上都有长远发展的机会。</p><p>而前者依然坐在他刚进公司的那张办公桌上，做着重复劳动的事情。前两年，两种人的收入也许差距不大，但是随着时间的推移，有一方却有可能出现爆发式增长。</p><p>毕业三四年后的差距，就是一直以来，一方通过不断地努力进取，而另一方却安于现状而造成的。如果可以自省，任何时候都可以从头开始。但如果只想装睡，别人真的无法叫得醒。</p><hr><p>在我读大学期间，每年过年都很期待同学聚会。因为大家都还正当年少，我依旧可以凭自己语不惊人死不休的本事，逗得女同学笑得花枝乱颤。</p><p>因为大家还没进入婚姻，也依旧可以和一群男同学去网吧开黑来一局DOTA，就算打输了也可以骂得很爽。大学毕业以后，大家走上了工作岗位，同学聚会的味道反而变了。</p><p>原本非常单纯的事情，却成了一种形式和应酬，甚至已经沦为一场展览会或汇报演出。有人开始递名片了，他是卖家具的，让我们结婚的时候去买他的家具；也有人想动用这层关系，求父母有权力的同学帮忙办事情；更有直接在同学聚会之后拉人入伙做生意，甚至是借钱的。</p><p>上学时的我们，没有层次、高低、等级之分，处在同一条起跑线上。现在我们的差距正在逐渐拉开，彼此心知肚明。混得好的，高谈阔论，一大群人追捧围绕着；混得不好的，沉默不语，一大群人敷衍冷淡着。</p><p>就像《夏洛特烦恼》里的那段台词，夏洛，这几年你死哪去了？年年同学聚会你都不来，你真有什么难处给我们大家说，大家就算帮不上你，不还能乐呵乐呵？哭笑不得，却是现实。</p><hr><p>我是一个执念很深的人，也曾有过很多学生时代的朋友，因为自己的感情过于丰沛，总想对身边人付出真心，拼命想粘住生命中出现的每一个人。</p><p>后来我听人说，友谊这个东西已经被世人捧得太高，它跟永恒其实没有太大关系，换了空间时间，总会有人离去。不要太念念不忘，也不要期待有什么回响。</p><p>你要从同路者中寻找同伴，而非硬拽着旧人一起上路。大概涂改是岁月的专长，谁都无法幸免。当昔日的同学陆续结婚生子以后，大家真的渐行渐远了。</p><p>没有共同的圈子，没有共同的经历。三观早被各自的生活磨砺得千差万别，一起说话，不知道哪句会触到逆鳞。就算有了悲欢喜怒，第一个想到分享或倾诉的对象已经不是他们。</p><p>可是偶尔，当我走过多年前大家一起嬉闹过的街道，听到多年前大家一起唱过的歌，或是翻到一张毕业时的合照，还是会怀着满心的祝福，希望大家永远平安喜乐。谢谢你们，曾在我的生命里留下印迹。</p><hr><p><strong>作者：衷曲无闻</strong><br><strong>链接：<a href="https://www.jianshu.com/p/b6776adc41be" target="_blank" rel="noopener">https://www.jianshu.com/p/b6776adc41be</a></strong><br><strong>来源：简书</strong></p>]]></content>
    
    <summary type="html">
    
      同学聚会，原本我是打算要去的，但看了一下参加的只有10个人，觉得有点难过，就决定不去了...
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>聆听逝水年华</title>
    <link href="https://dolyw.com/2018/11/07/2018-11-07-Dead-Year/"/>
    <id>https://dolyw.com/2018/11/07/2018-11-07-Dead-Year/</id>
    <published>2018-11-07T09:00:18.000Z</published>
    <updated>2019-05-16T12:31:41.089Z</updated>
    
    <content type="html"><![CDATA[<hr><p>哥们已经28了，好多朋友都说感觉我长不大。排除我童颜巨#￥（啊呸写歪了）的情况外，还有就是我的习惯和心态，依然是少年的模样，我爱喝几块钱的碳酸饮料，会熬夜看刚出来的动漫，和朋友玩游戏一玩就是一下午，还是没有攒钱的习惯，不知道为未来做打算，也许有一瞬会为生活所忧虑，但下一刻什么都不顾了。</p><p>但是尴尬的是，除了我之外，所有的人都成长了。</p><p>那些陪我通宵玩游戏的哥们，要么结婚生子照顾家庭，要么为事业奋斗到处赚钱，那些跟我一起路边撸串的老同学，有的长成将军肚，有的去搞研究秃了头，他们都很老成，跟他们在一起我都很不好意思，显得太嫩了。还有一直照顾保护我的父母，他们都生了白发，透过最公正的时间，我能感受到他们面对生活的力不从心。</p><hr><p>前段时间在街上我遇到了初恋女友，当时是个职业学院的御姐，在我的印象中身材非常火辣，总是化着烟熏妆，我第一次去酒吧就是她带我去的，把战战兢兢的我搂着带着坏笑说：轻松点，什么事都有第一次的。</p><p>当时我非常迷恋她，我感觉她的世界前卫又潮流，玩的东西都高出我们一个层面。</p><p>但再次遇见时，真的没认出来。</p><p>她已经成了两个孩子的妈妈，身材臃肿脸色疲倦，手上拎着一大堆超市买来的生活用品，她却能一眼认出我来，她冲我笑着说：你怎么还这样呢？</p><p>我的嘴巴已经可以塞下两个鸡蛋，当时我迷恋的御姐女神，现在成了大街上随处可见的中年妇女，手指上居然有茧子，穿着宽大的羽绒服，脸色泛黄也不化妆了，唯一可以唤醒我记忆的点，是她的笑容依旧亲切。</p><p>我和她在一个咖啡馆里聊了两句，两个孩子吵个不停，她说了些自己的遭遇，毕业找工作结婚和别人没什么不同，男人是建筑工地的工头，一个月才回几次家，两个孩子都是自己在带，现在就是个正儿八经的家庭妇女了。</p><p>我问她：你现在还玩游戏吗？还去酒吧吗？</p><p>她一脸不可思议：我什么时候去过酒吧？我怎么没印象了。</p><p>我心里一震，随后把话题岔开，这就是年华的威力，它可以把一个人在不经意间变成截然不同的另一个人，那个肤白貌美带着媚笑的坏女孩，在某个不经意的瞬间，已经被时间抹去了，甚至连记忆都没留下。</p><hr><p>还有我们小区的一个哥哥，在我们读书那会儿，他可是最出风头的，首先是打架厉害，当时治安不大好经常有小混混堵在路口抢我们钱，只要我们那片有孩子被欺负了，都是他去出头，二话不说就扑过去几飞脚几耳光，打得小混混哭爹喊娘，有一次一个人打五个人，拿着根铁棍舞的虎虎生风，打伤了两个吓跑了三个，此后再也没有混混来我们那片闹事。</p><p>还有就是多才多艺，篮球打得特别好，每次三分球空心入网的时候周围女孩子都会爆发刺耳的尖叫，当时他还玩音乐，是一个鼓手，打鼓的样子简直帅呆，导致后来我看《爆裂鼓手》的时候总是会想起他。</p><p>这样一个人，不算天之骄子，也算年少有为吧。</p><p>可是最近一次遇见他的时候，才知道他现在是个超市的小老板，胡子拉渣身材走样，胖的几乎迈不开腿，叼着一根烟用计算机算着账，他的儿子拿着一个玩具要他修，他接过来捣鼓半天，还是没捣鼓好。</p><p>我上去打了个招呼，他递给我一支烟，很有兴趣的问我在干什么，他的语气不再是高昂亢奋，反而带着中年人特有的沉闷。</p><p>我问他：你现在还打鼓吗？</p><p>他说：早不打了，我每天早上五点钟就得过来搬货，晚上十一点才回去，哪有时间搞那些…</p><p>分别的时候，我特别怀念那个少年，他带着一身伤走到我们中间，他笑骂：那几个狗日的都是孬种，都被我打跑了，以后再也不敢来了。</p><p>那时候的他，年少轻狂。</p><p>而现在的他，只剩彷徨。</p><hr><p>我终于明白，我是个被时光遗弃的幸运儿，我从年少到现在都没怎么改变，说实话都是上天眷顾。</p><p>比如说如果我突然一贫如洗，要一天做几份工作时，我还能这么淡然吗？</p><p>或者说要是我家人身体有恙，逼着我感受离别之苦，我还能这么无忧吗？</p><p>我没长大，只是生活没逼迫我而已。</p><p>没有成长，真的是一件无比幸运的事。</p><p>写这么一篇文章，只是为了记录此刻的自己，如果有一天我变成了另外一个模样，希望还能忆起，在自己的一生中，至少有一段时间还是保持单纯不拘世故的，而不是像很多人一样，突然一瞬间就消失了，此后音信全无。</p><hr><p><strong>作者：Seasee Youl</strong><br><strong>链接：<a href="https://zhuanlan.zhihu.com/p/48624123" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48624123</a></strong><br><strong>来源：知乎</strong></p>]]></content>
    
    <summary type="html">
    
      如果有一天我变成了另外一个模样，希望还能忆起，在自己的一生中，至少有一段时间还是保持单纯不拘世故的，而不是像很多人一样，突然一瞬间就消失了，此后音信全无...
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程安全和线程不安全</title>
    <link href="https://dolyw.com/2018/10/26/2018-10-26-Thread-Safe/"/>
    <id>https://dolyw.com/2018/10/26/2018-10-26-Thread-Safe/</id>
    <published>2018-10-26T07:18:18.000Z</published>
    <updated>2019-05-16T12:30:47.387Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><code>JVM</code>有一个<code>Main Memory</code>，而每个线程有自己的<code>Working Memory</code>，一个线程对一个变量进行操作时，都要在自己的<code>Working Memory</code>里面建立一个<code>Copy</code>，操作完之后再写入<code>Main Memory</code>。多个线程同时操作同一个变量，就可能会出现不可预知的结果。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性(多个线程先后更改数据造成所得到的数据是脏数据)</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>多线程并发不安全的原因已经知道，那么针对这个种情况，有两种解决思路</p></blockquote><ul><li>给共享的资源加把锁，保证每个资源变量每时每刻至多被一个线程占用</li><li>让线程也拥有资源(副本)，不用去共享进程中的资源(副本)</li></ul><blockquote><p>基于上面的两种思路，下面便是三种实施方案</p></blockquote><ul><li>多实例或者是多副本(<code>ThreadLocal</code>)，对应着思路二，<code>ThreadLocal</code>可以为每个线程的维护一个私有的本地变量，可参考<code>Java</code>线程副本–<code>ThreadLocal</code></li><li>使用锁机制<code>synchronize</code>或<code>lock</code>方式，为资源加锁</li><li>使用<code>java.util.concurrent</code>下面的类库，有<code>JDK</code>提供的线程安全的集合类</li></ul><h4 id="线程安全的集合对象"><a href="#线程安全的集合对象" class="headerlink" title="线程安全的集合对象"></a>线程安全的集合对象</h4><ul><li>Vector</li><li>HashTable</li><li>StringBuffer</li></ul><h4 id="非线程安全的集合对象"><a href="#非线程安全的集合对象" class="headerlink" title="非线程安全的集合对象"></a>非线程安全的集合对象</h4><ul><li>ArrayList</li><li>LinkedList</li><li>HashMap</li><li>HashSet</li><li>TreeMap</li><li>TreeSet</li><li>StringBulider</li></ul><h3 id="线程安全和线程不安全的小例子"><a href="#线程安全和线程不安全的小例子" class="headerlink" title="线程安全和线程不安全的小例子"></a>线程安全和线程不安全的小例子</h3><ul><li>在单线程运行的情况下，如果<code>Size = 0</code>，添加一个元素后，此元素在位<code>0</code>，而且<code>Size = 1</code></li><li>如果是在多线程情况下，比如有两个线程，<code>线程A</code>先将元素存放在位置0。但是此时<code>CPU</code>调度<code>线程A</code>暂停，<code>线程B</code>得到运行的机会。<code>线程B</code>也向此<code>ArrayList</code>添加元素，因为此时<code>Size</code>仍然等于<code>0</code>(注意哦，我们假设的是添加一个元素是要两个步骤哦，而<code>线程A</code>仅仅完成了步骤1)，所以<code>线程B</code>也将元素存放在<code>位置0</code>。然后<code>线程A</code>和<code>线程B</code>都继续运行，都增加<code>Size</code>的值。那好，现在我们来看看<code>ArrayList</code>的情况，元素实际上只有一个，存放在位置<code>0</code>，而<code>Size</code>却等于<code>2</code>。这就是<code>线程不安全</code>了</li></ul>]]></content>
    
    <summary type="html">
    
      简单的介绍在Java中的线程安全(Thread-Safe)和线程不安全以及线程安全和不安全的集合对象，还有一个通俗易懂的小例子
    
    </summary>
    
      <category term="Thread" scheme="https://dolyw.com/categories/Thread/"/>
    
    
      <category term="Thread" scheme="https://dolyw.com/tags/Thread/"/>
    
      <category term="Java" scheme="https://dolyw.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>坏孩子的夏天</title>
    <link href="https://dolyw.com/2018/10/14/2018-10-14-Bad-Children-Summer/"/>
    <id>https://dolyw.com/2018/10/14/2018-10-14-Bad-Children-Summer/</id>
    <published>2018-10-14T07:18:19.000Z</published>
    <updated>2019-05-16T12:30:38.319Z</updated>
    
    <content type="html"><![CDATA[<hr><p>2007年的九月份，我被丢到一个偏远的山区，那时我刚读高二，在学校闯了一个大祸，校方责令我休学，我爸已经对我彻底不抱希望了，就把我用绳子绑了丢到一个远房表舅家，说让我呆三个月了再回来接我。</p><p>那地方特别偏，是一个山洼洼里的小村庄，离最近的小镇都有十几公里，而且一天只有一趟车。</p><p>说穿了，就是和笑傲江湖里的令狐冲一样，我被罚上了思过崖。</p><p>我的手机、MP4、钱包都没能让带，还好我留了个心眼，在内裤里藏了五十块钱，不然就真的身无分文了。那个远房表舅热情的欢迎了我们，杀了一只鸡煮的汤贼香，让我觉得不是那么郁闷了。我绕着那个村子走了一圈，山清水秀空气新鲜，突然有了一个奇怪的想法，等我死了可以埋在这儿。</p><p>吃完饭后我爸打道回府，临走前叮嘱表舅：把他当你儿子待，该打打该骂骂，他可不是块省事的料。</p><p>表舅憨厚的笑了笑，然后把我爸送出村外。</p><p>晚上睡觉的时候觉得不适应，平时都带着耳机入眠，现在却只能听到蝉鸣蛙叫，我翻来覆去在床上挺尸了几小时，还是无法静心，我爬起来在柜子里找到一本书，是上个世纪的杂志，翻了几页看到一篇描写借腹生子最后擦出火花搞得家破人亡的三流小说，里面的用词隐晦又淫荡，我一边吐槽一边浮想联翩，竟然神奇的睡着了。</p><hr><p>第二天一大早我就醒了，正好表哥要去放牛，我的这个远房表哥比我大两岁，皮肤黝黑体格健壮，就是感觉脑子不大好，高中没读完就回家务农了，你和他说话说着说着他就傻笑起来，让人不寒而栗。但没办法，这地方就这一个同龄人，总得找个人陪着玩啊。</p><p>我说：表哥，我陪你一起去放牛吧。</p><p>表哥又傻笑了：走，带上馒头。</p><p>出门的时候我闻到空气里的芬芳，这是城市里无法体验到的气息，阳光暖暖地打在我们身上，让人身心愉悦。</p><p>放牛时我的多动症又犯了，本来那头水牛安安静静地在吃草，我用一块石头砸过去，命中牛的脑袋，它看我一眼，眼睛瞪得滚圆。</p><p>我问表哥：我听说有的牛疯起来连人都能顶死，是真的吗？</p><p>表哥说：不会，牛都很温顺。</p><p>我说：那我就放心了。</p><p>捡起一块更大的石头，正准备再砸的时候，那头牛猛地抬起头看着我，随后眼睛充血后蹄一蹬，速度奇快歪着脑袋，就像一台坦克轰了过来，我大叫一声转身就跑，心想真不该相信蠢货，妈的就这样子你还信誓旦旦的说是温顺？</p><p>那头牛在我后面穷追不舍，大有不把我毙于角下不罢休的气势，我跑的气喘吁吁向表哥求救：你想办法制住它啊。</p><p>表哥喊得比我还急：把你的衣服脱了，牛见了红色就急眼。</p><p>我低头一看穿的确实是红色短袖，连忙脱下来甩在一旁，那傻牛却没减速，反而冲得更快了，我在心里日了一百遍表舅母娘，看到前方是一个小湖，走投无路的我纵身一跳，然后往湖中央游了几步，回身一看，那牛终于不疯了，喝了几口水悻悻而回。</p><p>清晨的湖水冷入骨髓，我忍不住打了个喷嚏。</p><p>我觉得表哥不是真的蠢，明明可以抓住绳子制住牛，却还是任由那头疯牛追了我一路，肯定是想看我的笑话。</p><p>我忍不住更阴暗的想，说不定是嫉妒我，我在城里读书有吃的有玩的，他在这里天天和泥巴作伴，当然想看我出丑了，对，肯定是这样。</p><p>我的老师说我是个天生的坏胚子，这话一点都没错，在村子里呆了一个星期后，我就开始做坏事了。我发现了后山的一个小溪，那里的水特别清澈，水底的石子都可以一眼看到，我觉得风景不错，就多留了一会儿，后来听到几个女人的声音，连忙躲了起来。</p><p>那些女人越走越近，我的心砰砰作响，因为我意识到这应该是那些女人洗澡的地方，那几个村姑说说笑笑，脱了衣服拿着毛巾走下水，那一年我十七岁，第一次见到这么多女人的裸体，吓得大气都不敢出，这事儿要是被发觉了，以那些村民彪悍的作风估计得把我活活打死。</p><p>有个女人说：生了娃娃你的腰还是这么细，你是怎么吃的？</p><p>另一个女人说：吃不是最重要的，最重要的是要晚上动的勤。</p><p>第一个女人大笑：真不要脸。</p><p>这些对话让我血脉贲张，感觉脸和脖子都被火烧似的发烫，心想姑奶奶们快点洗完了走吧。</p><p>所幸天色渐黑，她们也不敢多待结伴而回，我等她们走后连忙跑回表舅家，一个晚上脑袋都在回想那些画面，突然有了一个绝佳的报复计划。三天后我在那条溪边守着，然后顺了几个女人的内衣，用东西包好后甩在了表哥的床下，当时我还挺兴奋，这玩意儿就是炸弹，爆炸了可不得了。</p><hr><p>第二天村里就传开了，女人们说有人偷看她们洗澡，那些男人气的满嘴粗话，那天晚上表舅妈发现了表哥床下的东西，差点气疯了，和表舅一起对表哥进行了身体和精神的双重毒打，看得我颇为解气，表舅一巴掌打在表哥脸上：孬货，这种事情你也敢干，传出去了我们还怎么做人？</p><p>表哥嘴角都流出血来，他不善言辞，一直说：不是……不是……</p><p>我装作不知情的样子走进房问：表哥，你怎么跪在地上？</p><p>他们一家三口默契的闭上嘴，表哥摸了摸嘴角的伤，带着奇怪的神色看了我一眼，我的心一紧，打了个哈欠装困回房。</p><p>回到吃的问题，除了第一天吃了一只鸡，后来几乎不见荤腥，不是白菜就是土豆，馋的我到处想办法，表哥这呆子没事的时候就跟着我，让我不好对村里的鸡下手，只好弄了几条蚯蚓去钓鱼。</p><p>在池塘旁边一坐就是一下午，表哥总是问一些奇怪的问题，比如问我会不会玩电脑，我心想我就是电脑游戏玩多了才成了这个德行，比如问我学校有没有图书馆，我说有个图书馆但是谁有时间去看啊，从早到晚都得上课。</p><p>表哥又想问，我不耐烦地打断他：别说话了，把鱼都吓走了。</p><p>表哥傻笑起来：这里没鱼的，这是个死水池塘。</p><p>我气的跳起来，心想我都呆一下午了你他妈现在才说，更加确信他是故意整我的。</p><p>过了几天我实在馋的受不了了，就用跟棍子打死了隔壁老奶奶家的一只母鸡，然后飞奔着往林子里钻，恰好碰到劳作回来的表哥，我冲他招招手，他扛着锄头跟过来。</p><p>我把老母鸡从怀里拿出来，问他：你会不会做？</p><p>表哥吓呆了：这不是……这不是隔壁……</p><p>我说：别废话了，你不想吃肉吗？</p><p>圣人都说食色性也，渴望食物是人类的本能，这句话打动了老实的表哥，他溜回家带了一些佐料，把鸡拔毛洗净涂上佐料，然后用报纸包好，埋在一个小土坑里，接着找了一堆柴火，在上面烧起来。</p><p>我急躁地问：这样做能好吃吗，还要等多久啊？</p><p>表哥慢慢加柴，说：几十分钟就好了。</p><p>过了一会儿，柴火烧完了，表哥把坑用东西刨开，我闻到了心旷神怡的肉香味，馋的我哈达子都快流出来。吃第一口的时候我都感动的哭了，怎么能好吃成这样，舌头被烫了我都没发觉，狼吞虎咽的吃完两条大腿，发现表哥还没动口，他有点踌躇，我拍拍他肩膀：木已成舟鸡已成肉了，就别做无谓的挣扎了。</p><p>表哥沉思半晌，也大快朵颐地吃起来。</p><p>我曾经看过一本小说，上面有这样一句话，带坏一个人很容易，先发现他的欲望，然后再满足他的欲望，最后再慢慢激发他更大的欲望，就成了。</p><p>我觉得表哥再跟我混几天，也会成一个痞子了。</p><p>那天晚上隔壁的王奶奶找过来，问我们有没有见过她的老母鸡，表舅母娘还陪着老人家找了一圈，表哥的心理素质太差了，脸涨的通红差点露馅，我连忙把他拉到房里，发现他的手上都是冷汗。</p><hr><p>我很喜欢看山间的夕阳，太阳缓缓沉入地平线的时候，我会感到平静。</p><p>我是个十七岁的坏孩子，只想把青春的悸动发泄干净。</p><p>有一天我正躺在树下看夕阳的时候，突然感觉胳膊一凉，随后就是一阵剧痛，我看到一条青色的蛇迅速的隐入草里。我大声叫了起来，胳膊慢慢的肿起来，有点麻有点痛，我想起电视剧里的情节，被毒蛇咬了都活不过几小时，我的心沉入谷底，慢慢陷入绝望的情绪中。</p><p>表哥听到我的呼叫跑过来，满头是汗的问我：怎么啦怎么啦？</p><p>我牙齿打颤：我被……被蛇咬了……</p><p>表哥拿起我的手看了几眼，二话不说把我背起来往山下跑，他跑的太快了，我看到那些翠绿的树往后倒，他脖子上的汗都甩到我脸上，我忍不住忏悔：表哥，那些内衣是我塞到你床下的。</p><p>表哥喘着气说：我知道，那个袋子是你来的时候带过来的。</p><p>我说：我枕头下还有五十块钱，你还给王奶奶吧。</p><p>表哥说：你少说话，我带你找医生。</p><p>我感觉手臂越来越麻了，忍不住哭起来：表哥，我是不是要挂了？</p><p>表哥没有再回答我，像头蛮牛似的往前冲，天色黑透的时候到了一户人家门口，找到了一个曾经做过医生的老头，老头抓起我的手看了几眼，摇了摇头。</p><p>我嚎啕大哭起来，我才十七岁啊，我还是个处男呢，我不想死啊。</p><p>老头大声呵斥我：吵吵什么，就是被土蛇咬了一口，什么要死要活的，上点草药明天就好了。</p><p>我连忙一抹脸上的鼻涕眼泪：不是毒蛇啊？</p><p>老头说：你看都快消肿了，毒蛇的话你现在还能说话吗？</p><p>表哥在我旁边听到这话，又嘿嘿嘿的傻笑起来。</p><p>人的一生，需要一次濒临死亡的经验，它会让你明白生命多么宝贵，世界是多么美好。</p><hr><p>我不再折腾了，闲的时候就帮表哥做做农活，晚上就和他下下象棋，我越来越觉得他是大智若愚了，下棋的鬼招太多了，有时候让我一个子都能赢。</p><p>三个月就快到了，我居然对这个宁静的小村庄有点不舍，临走的前几天突然下起暴雨，本来以为只是短暂的，不料连着下了好几天还越来越大，临走的前一天夜里听到外面闹哄哄的，我穿上衣服出门，看到那些村民都拿着工具，雨水快把庄稼淹死了，他们得挖一条渠道把水排出去，不然一年的收成就全泡汤了。</p><p>我第一次见识到什么叫拼命，不分男女老少全上阵了，快速的用锄头挖着泥，不要命的劳作去抢救庄稼。我也拿了一把锄头上去帮忙，表哥说：你明天就回去了，回去睡觉吧。</p><p>我说：我也能帮帮忙。</p><p>雨水砸在身上就像子弹，发出清脆的响声，我不记得自己干了多久，只知道做到后来胳膊发软小腿发抖，而脑袋陷入一片空白，只残存着一个念头，我必须要把它做好。水线还是在慢慢上涨，我祈祷上苍，停一会儿雨吧。</p><p>就在我快要坚持不住的时候，村民爆发一阵欢呼声，那些田的渠道全部打通，水顺着一个方向全部倾斜流出，我无力的坐在田里，突然有一种前所未有的畅快感，忍不住大声长叫一声。</p><p>回村里的路上，那些村民给了我最大的善意，有的人帮我拿锄头，有的人给干净衣服披在我肩膀上，有的人还给我散烟，要知道，在这地方纸烟可是稀缺品。</p><p>有个村姑还摸了摸我的脸，笑着说：你这城里的小伙子，本来以为是个爱看女人洗澡的小流氓，没想到还不错。</p><p>我脸都白了：你……你怎么知道的？</p><p>那村姑说：哎哟，你以为躲树后别人都看不见哟。</p><p>周围一片笑声，我的脸烫的见不了人，怪不得此后再也没姑娘去那洗澡，原来是我的奸计早就败露了。</p><p>早上我爸如约过来接我，我离开村子的时候，雨已经停了下来，久久未见的太阳慢慢升起来，表哥在村口用力的喊了一声：喂——</p><p>我听到漫山遍野的回声，冲表哥挥挥手，表哥竖起一个大拇指，又傻笑起来。</p><p>时至今日，我都记得那个画面，一个坏孩子的十七岁，在一片纯真中找到了救赎。</p><hr><p><strong>作者：Seasee Youl</strong><br><strong>链接：<a href="https://zhuanlan.zhihu.com/p/39172878" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39172878</a></strong><br><strong>来源：知乎</strong></p>]]></content>
    
    <summary type="html">
    
      2007年的九月份，我被丢到一个偏远的山区，那时我刚读高二，在学校闯了一个大祸，校方责令我休学，我爸已经对我彻底不抱希望了.....
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>彼以路人待我，我亦以路人报之，彼以国士待我，我亦以国士报之</title>
    <link href="https://dolyw.com/2018/10/14/2018-10-14-Passerby-Waiting-Me/"/>
    <id>https://dolyw.com/2018/10/14/2018-10-14-Passerby-Waiting-Me/</id>
    <published>2018-10-14T07:18:18.000Z</published>
    <updated>2019-05-16T12:30:41.519Z</updated>
    
    <content type="html"><![CDATA[<hr><p>有这样一个老头，他家境优越乐善好施，只要有人找他求助他都不遗余力的去帮别人，因此口碑非常不错。</p><p>在一个冬天，铺天盖地的瑞雪里一拐一拐走来一个乞丐，衣服全是破洞身上奇臭无比，找别人讨饭吃别人都捂着鼻子要他滚，他又冷又饿，浑身发抖的敲开那个老头的门。</p><p>乞丐带着哭音乞讨：老善人，赏口饭吃吧。</p><p>老头扭头走回自己的房，然后半晌都没出来，乞丐心慢慢地沉了下去，难道说这个老头声名远播的好名声都是装出来的？</p><p>乞丐冻得受不了了，正准备去别处时，老头急匆匆的跑出来，然后把乞丐拉到屋子里，原来刚刚他是在屋子里烧了一盆旺火，整个屋子温暖如春，老头还拿来一件袍子披在他身上，然后要佣人做了一大桌子菜。</p><p>乞丐有点慌张，说：您给我一碗热饭就可以了。</p><p>老头说：今天是小年夜，你既然来了就是我的客人，我们喝两杯吧。</p><p>乞丐已经饿的太久了，饭菜一上来就开始狼吞虎咽，老头等他吃饱后就开始给他倒酒，然后询问他的身世。原来这个乞丐是个年轻人，父母都在战争中被杀了，他也被打伤一条腿，干不了重体力只能一路乞讨。老头叹了一口气，真是宁做太平犬，不为乱世人啊。</p><p>那晚两人聊了很久，老人还让乞丐睡到自己的床上，乞丐执意不肯，说自己身上太脏了，不能把这么好的床给糟蹋了。</p><p>乞丐就睡在大厅上面的地板上，第二天一早，乞丐就失踪了，没有人知道他去了哪里。</p><hr><p>时光飞逝，过了几十年，老人做了一辈子善事，却没有一个善终。建国后的一场大运动，老人成了众矢之的，家里所有的东西要么被砸要么被抢，两个儿子都被枪毙了，不仅如此，他还被拉到大街上批斗，那些曾经被他帮助过的人用各种恶毒的话骂他，有的还用石头臭鸡蛋砸他的脸，这种遭遇持续了很长时间，老人精神出现了问题，眼睛瞪得像个铜铃张大着口，却一个字都说不出口，有人打他，他就发出野兽一样的叫声，渗人的声音吓哭了很多小孩子。</p><p>又到了冬天，老人晚上被关在牛棚，白天就被拉出去批斗，老人穿着一件破布衫，冻得瑟瑟发抖，脸上的伤越来越严重，肉都翻了出来，有人预言，这老人活不过三天了。就在那天，众人正兴致高涨的批斗老人时，有个中年人像个疯子一样扑了出来，挡在老人身前，人们威胁他要和地主保持距离，不然连他一起打，他挡在老人面前带着凶气怒骂：你们这群人都是畜生，你们谁没吃过他家的饭，谁没有被他帮过，你们还有没有人性？</p><p>这声呐喊让那群人都住手了，每个人脸上都有愧色，可是很快就有人冒出来说：那是因为我们都被他压榨着，他有那么多钱都是压榨我们劳动人民得来的，打倒地主老财，打倒封建分子！</p><p>就这样，人们再次一拥而上，那个中年人死死的护住老人，自己被打的满身是伤。</p><p>那是一个疯狂的年代，所有的理性都被疯狂所淹没。</p><p>那个中年人要把老人从牛棚里救出来，结果被看守的人发现了，看守人要中年人快点滚，不然就把他们关到一起，第二天一起拉出去批斗。中年人发了狠，拿出柴刀剁了自己一个手指，他眼睛里全是血丝，对着那个看守人说：你别逼我杀人，你别逼我杀人。</p><p>看守人被吓傻了，中年人背起老人就往外走，这时候看守人才发现，中年人还是个瘸子。</p><p>这个地方肯定是不能呆了，中年人连夜背着老人往城外走，雪越下越大，老人的身体越来越冷，中年人脱了自己所有的衣服套在老人身上，打着赤膊把老人背到一个村子里，那些农民还是很善良的，给了他们一些衣服和食物，让他们免于冻死饿死。</p><p>奇迹般的，两人活着到了湖北的一个农村，却没找到老人仅剩的那个亲戚，绝望之下，老人终于一病不起，那个中年人到处找医生，每个医生都说老人的时间到了，没办法再救了。</p><p>老人死前的一刻突然回光返照，认得清人也说得出话了，他握住那个中年人的手满脸都是眼泪：你何苦如此，你何苦如此……</p><p>中年人红着眼眶说：当年不是您给我一碗饭吃，我早就饿死了，这些事相比于您对我的恩情不算什么。</p><p>老人感慨：想不到我一生为善，最后却落得一个家破人亡的下场，连子女都死完了，老天不公啊……</p><p>说完这句话，老人就撒手人寰了，中年人也在此刻，做出一个赌上一生的决定：老人没有子女，他要为老人做一辈子守陵人。</p><hr><p>中年人为了给老人守孝，就在那个村庄住了下来，一住就是数十年，他的手脚都有残疾，干不了重体力，就喂了一些鸡鸭鹅，然后卖到镇子里养活自己，他的日子过得很清贫，却给老人立了一块大碑，每年清明都会带上纸钱花圈去踏青，村民都说他是个怪人，自己家的房子都乱七八糟，把老人的坟却收拾的很漂亮。</p><p>慢慢地，中年人也变成了一个老人，他没有妻室，也没有子女，死的时候身边没有一个人，只有一封遗书，上面写了那些他从来没有提起的往事，他请求街坊邻居把他葬在老人的墓旁，让他死后也能守护老人。</p><p>村民大为感动，替他操办了后事，也给他立了一块大碑。两人的坟墓挨得很近，那片林子被称为“义子林”。</p><p>从贵州至湖北，有一千多公里，一个瘸子背着一个老头走了大半年，中途经历千难万苦，只要有一口吃的，中年人都会让老人先吃，老人生了病，他就在医生门口磕头，磕的脑袋血迹斑斑，让医生无法拒绝，老人没了子嗣，中年人可以为他守一辈子墓。</p><p>这些都是人性的光辉，人之所以能成为万物之主，不仅是因为人有思想能趋利避害，更是因为人会感恩懂报答，可以为一饭之恩搭上一辈子。</p><p><strong>彼以路人待我，我亦以路人报之，彼以国士待我，我亦以国士报之！</strong></p><p>每每在“义子林”的石碑上看到这句话，都会让我热泪盈眶。</p><hr><p><strong>作者：Seasee Youl</strong><br><strong>链接：<a href="https://www.zhihu.com/question/290003248/answer/471408109" target="_blank" rel="noopener">https://www.zhihu.com/question/290003248/answer/471408109</a></strong><br><strong>来源：知乎</strong></p>]]></content>
    
    <summary type="html">
    
      有这样一个老头，他家境优越乐善好施，只要有人找他求助他都不遗余力的去帮别人，因此口碑非常不错.....
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>这是普普通通的一天</title>
    <link href="https://dolyw.com/2018/10/13/2018-10-13-Common-Day/"/>
    <id>https://dolyw.com/2018/10/13/2018-10-13-Common-Day/</id>
    <published>2018-10-13T15:18:18.000Z</published>
    <updated>2019-05-16T12:30:06.737Z</updated>
    
    <content type="html"><![CDATA[<hr><p>早上起来，她发现家里停电了。于是没办法用热水洗漱，用电吹风吹头发，不能热牛奶，烤面包，只好草草打理一下就出门。</p><p>刚走进电梯，邻居家养的小狗一下子冲进来扑住，上周刚买的米白长裙上顿时出现两只黑黑的爪印儿。</p><p>开车被警察拦，才想起来今天限行，罚了一百。</p><p>到了公司，正好晚了一分钟，又罚五十。</p><p>冲进会议室开例会，老板正在宣布工作调整的名单。她的业务居然被无故暂停，她的职位则被一个不学无术的家伙所取代。</p><hr><p>午餐时间，所有人都闹着要新任主管请客，一窝蜂笑闹着出了门，没有人叫她。</p><p>她一个人去了餐厅，刚把一口饭送进嘴里，重要客户打来电话。</p><p>对方取消了金额最大的一笔订单，年底的奖金泡汤了。</p><p>她看着面前的午餐，再无半分胃口。</p><p>刚回公司，电话响起，妈妈在电话那端哽咽，说姥姥的病又重了，可能熬不过这个月了。</p><p>她安慰着妈妈，丝毫不敢提及自己的工作变动，只说一定尽快回去看姥姥。</p><p>放下电话，短信声响起。</p><p>居然是暗恋了十年的对象发来的消息：HI，我要结婚了。</p><hr><p>黄昏，她站在回家的路边等着打车，可每位司机听到要去的地点都拒载。无奈，她踩着高跟鞋，拎着沉重的电脑包，向家的方向走去。</p><p>脚很快磨出了血泡，实在走不动了，太痛了，她蹲下来缓缓地揉着伤口。</p><p>夜色笼罩，头顶的月亮冷冷地俯瞰着她，仿佛无声的提醒，家里还是一片黑暗。</p><p>她的眼泪在一瞬间夺眶而出。</p><p>她站起来，擦干眼泪，摇晃着继续往前走。</p><p>直到下一个路口，有一辆车终于停下来。报了地址，司机和气地说这么巧，我们住同一个小区，看小姑娘你走得辛苦，正好收工，免费送你回家。</p><p>她连声道着谢上了车，电话响起。</p><p>客户在另一端说，虽然订单取消，可是她的敬业态度让他觉得感动。不知她是否对新的岗位感兴趣？如果愿意跳到自己的公司，薪水涨一倍，职务也提升。他说，其实我等你辞职已经等了好久。</p><p>她惊喜地说着谢谢，心情豁然开朗起来。</p><p>于是顺手给暗恋对象回了个短信，说祝你幸福。</p><p>手机屏幕闪亮，是他发来的回复：今天我跟阿姨通了电话，我们这周末一起回家看姥姥吧。</p><p>她惊疑地回：为什么你要陪我回家看姥姥？</p><p>他发来一个笑脸：如果不是想让姥姥开心，我不会把求婚提前这么久的。</p><p>她不敢置信地望着那一行话，张大了嘴巴，手足无措。</p><p>他像知道她的心事，又发：我都知道，我喜欢你。</p><p>她眼圈一下子又红了，心里却轰轰炸开几朵烟花。</p><p>一路抿着嘴笑。回家，拿出钥匙，邻居家的门却先开了。</p><p>邻居笑眯眯地说：今天我遛狗回来，发现你家的电闸坏了，就叫我老公帮你修好了。</p><p>在她的身后，那只小狗探出头来，汪汪两声，欢快地摇着尾巴。</p><p>她推开家门，一室融融，满眼暖意。</p><hr><p><strong>作者：辉姑娘，出自同名新书《这世界偷偷爱着你》</strong></p>]]></content>
    
    <summary type="html">
    
      早上起来，她发现家里停电了。于是没办法用热水洗漱，用电吹风吹头发，不能热牛奶，烤面包，只好草草打理一下就出门。刚走进电梯.....
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>你从不知道那些缺钱的人</title>
    <link href="https://dolyw.com/2018/10/13/2018-10-13-Never-Know-Money/"/>
    <id>https://dolyw.com/2018/10/13/2018-10-13-Never-Know-Money/</id>
    <published>2018-10-13T14:18:18.000Z</published>
    <updated>2019-05-16T12:30:34.281Z</updated>
    
    <content type="html"><![CDATA[<hr><p>我曾见过一个老奶奶，因为坐公交车投错了钱，本来是一块钱却放进去五块钱，她求了那公交车师傅一路。因为车上人太多了，公交车师傅一直推脱说自己没看见，老奶奶说了十几分钟那师傅也不理不睬，老奶奶就捂着眼睛在旁边哭了起来。</p><p>旁边的一个小姑娘看不过去了，就从包里拿出五块钱递给老奶奶，说她没投错钱钱掉在地上了。</p><p>老奶奶看了一眼，握着小姑娘的手说：谢谢你丫头，但我的钱没这么新。</p><hr><p>我曾见过路边卖油条豆浆的两夫妇，在客流量最多的时候找错了钱，不知道是多找了十块还是二十，追着那客人跑了几分钟。那客人骑着摩托车，不知道是真没听见还是假没听见，踩着油门拐个弯就不见了。</p><p>那妇女摔在地上，膝盖都磕出血来，边哭边骂自己的丈夫是瞎子。</p><p>他老公涨红了脸不说话，过去拉她起来，重重地抽了自己一嘴巴。</p><hr><p>我曾遇过一个小女孩，背着破布书包穿着旧牛仔裤，在没有路灯的街道上低着头走了一圈又一圈，那时候已经入冬了，小女孩被冻得脸发白。</p><p>我们把车停到她旁边，女朋友问：小妹妹，你在干嘛呢？</p><p>那小女孩眼眶红红的：我的钱丢了。</p><p>女朋友说：快回家吧，天这么晚了你爸妈会担心的。</p><p>小女孩哽咽的说：姐姐你不知道，那些钱是我奶奶给我买资料的，她捡了一个月的塑料瓶才攒了这些钱。</p><hr><p>在你们看来，为了这点钱至于吗？</p><p>五块钱只不过是一杯饮料，十块钱才两个小时的网费，三十多块钱不过就是一包烟钱。</p><p>但对于他们来说，这些钱就是他们的希望，生活赋予他们巨大的重压，这些钱都是他们溺水后的稻草。</p><p>这个世界太喜欢以己度人了，你看惯了明星的灯红酒绿，每天路过的都是繁华的街道和高楼大厦，买的都是专卖店的东西，就会觉得那些贫穷和疾苦不存在，是博同情和搞笑。</p><p>我们不仅要仰望天空，更要学会俯视尘埃。</p><p>那些说钱不重要的人，一般都是没长大的人。</p><hr><p>我读高中的时候特别大手大脚，生活费一个月上千，其中充点卡买衣服就要好几百，钱用完了就到处借，借不到了就回家去我爸柜子里“拿”，有一次又偷偷的回家，拿了一千块钱准备找死党胡吃海喝的时候，被我爸逮个正着，尴尬的是连狡辩的机会都没有，我爸开门刚好看到我拿着钱欢欣雀跃，我心想完了完了这下死定了。</p><p>我爸沉着脸问：钱花完了？</p><p>我红着脸点点头，准备迎接一顿暴打，结果他只是说了句：在学校用点心，不要总是在外面玩乱七八糟的。</p><p>我看到他提着一个袋子，里面有四个馒头，想起桌子上只有两盘青菜，这就是他凑合对付的中饭。那一刻我才知道羞愧，我之所以过的轻松，无非是有人帮我承担了那份艰难。我问：您中午就吃这个吗？</p><p>我爸笑了笑：反正家里没人，简单凑合一下就行了。</p><p>我低下头不知道该说什么，他却拍拍我的肩膀，说了句让我止不住眼泪的话。</p><p>对了，你还没吃饭吧，走我们出去吃去！</p><hr><p><strong>作者：Seasee Youl</strong><br><strong>链接：<a href="https://www.zhihu.com/question/65213469/answer/229296011" target="_blank" rel="noopener">https://www.zhihu.com/question/65213469/answer/229296011</a></strong><br><strong>来源：知乎</strong></p>]]></content>
    
    <summary type="html">
    
      我曾见过一个老奶奶，因为坐公交车投错了钱，本来是一块钱却放进去五块钱，她求了那公交车师傅一路。因为车上人太多了，公交车师傅一直推脱说自己没看见.....
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>我的人生不能将就(男)</title>
    <link href="https://dolyw.com/2018/10/13/2018-10-13-Life-Man/"/>
    <id>https://dolyw.com/2018/10/13/2018-10-13-Life-Man/</id>
    <published>2018-10-13T13:18:18.000Z</published>
    <updated>2019-05-16T12:30:25.274Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="18岁"><a href="#18岁" class="headerlink" title="18岁"></a>18岁</h3><p>你读了大学</p><h3 id="20岁"><a href="#20岁" class="headerlink" title="20岁"></a>20岁</h3><p>你大二结束，开始悔恨自己前两年的幼稚行为，于是开始努力</p><h3 id="22岁"><a href="#22岁" class="headerlink" title="22岁"></a>22岁</h3><p>你大学毕业了，却发现找不到一份令自己满意的工作</p><h3 id="26岁"><a href="#26岁" class="headerlink" title="26岁"></a>26岁</h3><p>你发现身边的人都结婚了，婚礼的份子钱逐年递增，春节回家，父母带你串亲戚，变成了带你去相亲看对象，见了十几个姑娘，你每次都觉得比那个她差一点</p><h3 id="28岁"><a href="#28岁" class="headerlink" title="28岁"></a>28岁</h3><p>这年你遇到了一个和你遭遇差不多的姑娘，你们有一搭没一搭的聊着，她说:你还不错，你喝了一口可乐说:你也是，你还不确定喜不喜欢她，双方家长就已经摆好了订婚宴，结婚的前一周，你和朋友出去喝酒，说不想结婚，朋友说，你就是想太多，谁不是这样过来的？</p><h3 id="29岁"><a href="#29岁" class="headerlink" title="29岁"></a>29岁</h3><p>你们终于结了婚，婚礼办的不大不小，朋友来的不多不少，攒了几年想去实现理想的钱，搭在了这一场百人的私人庙会上，婚礼进行到中间，司仪带着标准的商业化微笑对着台下的亲朋说，要不要让他们亲一个，台下的那些人跟着一起起哄，不知道为什么，你简简单单的亲了一口，两人回到一开始的站位，你小声的说了一句:我爱你，那个昨天还看不惯你倒腾模型的新娘，愣了一下说:我也爱你，你不确定她是不是对你说的，就像你不确定自己是不是对她说的一样，婚礼结束后，并没有你想象的浪漫，你听着外屋的新娘一笔一笔的算着份子钱，想着才不过两年，怎么就这样了，想着想着，洞房夜就这样睡着了</p><h3 id="30岁"><a href="#30岁" class="headerlink" title="30岁"></a>30岁</h3><p>她怀孕了，辞掉了工作，在家养胎，你在公司逐渐有了点地位，手里管着十来个人，独立负责一个项目，结婚前陪嫁的那辆二十多万的车，也变成了你一个人的独享，但你依然不敢放松，每次加班，电话那头都是抱怨和委屈，但你不能争辩什么，谁让她怀了你的孩子，在这一刻，不论是她的父母还是你的父母，都无条件的站在她这一边</p><h3 id="31岁"><a href="#31岁" class="headerlink" title="31岁"></a>31岁</h3><p>孩子出生了，前前后后连孕检带住院费花了十万块钱，不过无所谓，你看着你的孩子，怎么看怎么喜欢，高兴的仿佛这是你的新生</p><h3 id="32岁"><a href="#32岁" class="headerlink" title="32岁"></a>32岁</h3><p>这是你人生最不愿意重复的一年，平均睡眠三小时，孩子每一个小时都要闹腾一次，第二天拖着睡不醒的眼睛去上班，老板说你上班不干活，回家媳妇说你不干活，你想了半天不明白，那谁干活呢？那辆开了三年的车，成为了你真正的家，你不再抱怨路上拥挤的交通，你甚至希望再多堵车一会，回到家，你关了发动机，在车上点了一根烟，这是你每天最幸福的十分钟，车前是功名利禄，车尾是柴米油盐</p><h3 id="35岁"><a href="#35岁" class="headerlink" title="35岁"></a>35岁</h3><p>你因为身体越来越差 加班越来越少 晋升的速度也越来越缓慢 那天下班，媳妇告诉你 孩子要上幼儿园了 双语的一个月3000 你皱了皱眉头，那边就已经不耐烦了 “四单元的老王家孩子，一个月6000” “你已经这样了，你想让孩子也输？” 你没说话，回屋给媳妇转了6000块钱 这笔钱，你原本打算给自己过个生日，买个新电脑</p><h3 id="38岁"><a href="#38岁" class="headerlink" title="38岁"></a>38岁</h3><p>孩子上了一年级 老师说一年级最关键，打好基础很重要 你笑着说，是是是，老师您多照顾 新生接待的老师看着你不明事理的脸 给你指了一条明路 “课外辅导班，一个月2200”</p><h3 id="40岁"><a href="#40岁" class="headerlink" title="40岁"></a>40岁</h3><p>孩子上了三年级 老师说，三年级，最关键，承上启下很重要 你笑着说：是是是，正打算再报个补习班</p><h3 id="44岁"><a href="#44岁" class="headerlink" title="44岁"></a>44岁</h3><p>孩子上了初中 有一天回到家，她对你说 爸爸，我想学钢琴 你没什么犹豫的 你以为这些年，你已经习惯了 但那句“爸爸现在买不起”你始终说不出口 好在孩子比较懂事 她说：爸爸没事，要不我先学陶笛也可以 你看着这么懂事的孩子，却开心不起来</p><h3 id="46岁"><a href="#46岁" class="headerlink" title="46岁"></a>46岁</h3><p>孩子上了一个不好不差的高中 有一天你在开会，接到了老师的电话 电话里说你的孩子在学校打架了 叫你去一趟 你唯唯诺诺的 和那个比你还小5岁的领导请了个假 到学校又被老师训了一通 无非台词就是那一句 你们做家长的就知道工作，能不能陪陪孩子 你看着这个老师，有点可笑 好像当时说： 家长在外辛苦点 多赚点钱让孩子多补补课的和他不是一个人</p><h3 id="50岁"><a href="#50岁" class="headerlink" title="50岁"></a>50岁</h3><p>孩子上了大学 很争气，是一个一本 他学的专业你有点看不懂 你只知道工作不一定好找 而且学费还死贵 你和他深夜想聊聊 准备了半斤白酒，一碟花生米 你说着那些曾经你最讨厌的话 还是要为以后工作着想 挑个热门的专业 活着比热爱重要 你们从交流变成了争吵 你发现，你老了 老到可能都打不过这个18岁的孩子 你说不过他，只能说一句：我是你爸爸！ 孩子看着你，知道再怎么争辩都没用 这场确立你最后威严的酒局不欢而散 你听的不真切 在孩子回自己屋的路上好像叨叨了一句 “我不想活的像你一样” 怎么就哭了呢？50岁的人了 一定是酒太辣了，对不对 一定是酒太辣了</p><h3 id="55岁"><a href="#55岁" class="headerlink" title="55岁"></a>55岁</h3><p>孩子工作了，似乎有一点理解你了 但你却反了过来，你说不要妥协</p><h3 id="56岁"><a href="#56岁" class="headerlink" title="56岁"></a>56岁</h3><p>孩子也结婚了 你问他喜欢那个姑娘么 他愣了愣说：喜欢吧</p><h3 id="60岁"><a href="#60岁" class="headerlink" title="60岁"></a>60岁</h3><p>辛苦了一辈子，想出去走走 身边的那个人过了30年 你依旧分不清到底喜不喜欢 你们开始规划旅游路线 这么多年了 你们还是存在分歧，还是在争吵 某个瞬间，你觉得 这样可能也挺好 一切都准备好了 儿子说：爸妈，我工作太忙了 可以帮我照顾一下孩子么 你们退了机票，又回到了30年前</p><h3 id="70岁"><a href="#70岁" class="headerlink" title="70岁"></a>70岁</h3><p>孩子的孩子也长大了， 不用天天操心了 你下定决心说：一定要去玩一趟 可是手边的拐杖 只能支持你走到楼下的花园</p><h3 id="75岁"><a href="#75岁" class="headerlink" title="75岁"></a>75岁</h3><p>你在医院的病床上 身边聚满了人， 你迷迷糊糊的看见医生摇了摇头 周围那些人神情肃穆 你明白了，你要死掉了 你没有感到一丝害怕 你突然问自己， 我到底是什么时候死掉的呢？ 你想起来30岁的那场婚礼 原来，那时候，你就死掉了吧 依照惯例 死前的3秒， 你的大脑要走马灯 倒叙你这75个年头的一生 画面一张一张的过 1秒 2秒 两秒过去了 你面无表情的看着这两秒内的回忆 第3秒 突然你笑了 原来已经回到了15岁的那一年 你看见一个男孩 他叼着一袋牛奶， 背着书包 从另一个女孩家的阳台下跑过 那个男孩朝窗户里看了看 那是15岁的你暗恋的那个女孩子 你想不起来她长什么样子了 最后一秒你努力的回忆着 然后终于笑了出来 3秒过去了 身边的人突然间开始嚎啕大哭 你可能听不清了 你最后听到的嘈杂的声音 是一群十五六的少年 起着哄说的 答应他 答应他 答应他</p><hr>]]></content>
    
    <summary type="html">
    
      我的人生不能将就(男)
    
    </summary>
    
      <category term="Article" scheme="https://dolyw.com/categories/Article/"/>
    
    
      <category term="Article" scheme="https://dolyw.com/tags/Article/"/>
    
  </entry>
  
</feed>
